<!DOCTYPE html>
<html lang="en"><head><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/highlight-dark.min.css"><link rel="stylesheet" href="/css/main.css"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>E2E Dockerizing a MEAN Stack Application</title></head><body><nav class="navbar navbar-expand-md navbar-dark fixed-top bg-dark"><a class="navbar-brand" href="#">Luis Quintanilla</a><button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarCollapse"><ul class="navbar-nav mr-auto"><li class="nav-item active"><a class="nav-link" href="/">Home</a></li><li class="nav-item"><a class="nav-link" href="/about.html">About</a></li><li class="nav-item"><a class="nav-link" href="/posts/1">Blog</a></li><li class="nav-item"><a class="nav-link" href="/events.html">Events</a></li></ul></div></nav><main role="main" class="container"><div class="mr-auto"><h2>Introduction</h2>
<p>Lately I've been getting familiar with <a href="https://docker.com">Docker</a>. I have built single container applications using a <code>Dockerfile</code> and run them locally. This works fine, especially for deployment purposes to a production VM but it's no different than setting up the VM with all the required dependencies and pushing updates via FTP or source control. However, one of the features that I have found extremely useful is multi-container building and deployment via <code>docker-compose</code>. With <code>docker-compose</code>, not only can I build and run my application, but also dependent services like databases, caches, proxies, etc. Best of all, the builds are standardized and initialized at once without having to individually install the dependencies and components. This writeup explores how to containerize a MEAN stack application and set up a <code>docker-compose.yml</code> file for it to build and start the server and database services defined within it.</p>
<h2>Requirements</h2>
<p>This writeup assumes that <code>Docker</code>, <code>Docker-Compose</code> and <code>Node</code> are installed on your PC.</p>
<h2>The Application</h2>
<p>The application is a CRUD todo MEAN stack application. The repo for this application can be found <a href="https://github.com/lqdev/todomeandockerdemo">here</a>.</p>
<h3>Project Structure</h3>
<pre><code class="language-text">|_models (Mongoose models)
| |_todo.model.js
|_public
| |_scripts
| | |_controllers
| | | |_main.controller.js
| | |_services
| |   |_todo.service.js
| |_views
| | |_main.html
| |_app.js (front-end application)
| |_index.html
|_Dockerfile (server service)
|_docker-compose.yml
|_api.js (todo api routes)
|_config.js
|_server.js (back-end application)
</code></pre>
<p>The front-end is built with <code>AngularJS</code> and the back-end is built with <code>NodeJS</code> using the <code>Express</code> web framework and <code>MongoDB</code> database. <code>MongoDB</code> models are defined with the <code>Mongoose</code> package. In the application, users can create, view, update and delete todo tasks. The <code>Dockerfile</code> is used to define the container for the web application and the <code>docker-compose.yml</code> defines both the <code>MongoDB</code> database container as well as the web application container defined in the <code>Dockerfile</code>.</p>
<h2>The Docker File</h2>
<pre><code class="language-docker">#Define base image
FROM node:8

#Set Working Directory
WORKDIR /app

#Copy pakage.json file from current directory to working directory
ADD package.json /app

#Install npm packages
RUN npm install

#Copy all application files from local directory to working directory
ADD . /app

#Open port where app will be listening
EXPOSE 3000

#Start application
CMD ['npm','start']
</code></pre>
<h3>Define Docker Image and Application Directory</h3>
<p>The <code>Dockerfile</code> has no extension and the syntax is like a standard text file. <code>#</code> characters denote comments. <code>Docker</code> works based off images which are basically pre-built packages that are stored in one of many registries such as <code>DockerHub</code>. <code>DockerHub</code> can be thought of as a package repository/manager like <code>npm</code> or <code>dpkg</code>. In the first two lines of the file we define which base image we want to create our container with. Since this is a MEAN stack application built entirely in <code>JavaScript</code>, we'll be using the <code>node</code> version 8 image. Then we want set the directory in which our application will reside. We do this by using the <code>WORKDIR</code> command and setting <code>/app</code> as our application directory, but any directory of your choosing is valid.</p>
<h3>Install Dependecies</h3>
<p>All of our dependencies should be defined in our <code>package.json</code> file. In order to install these dependencies in our container, we need to copy our local <code>package.json</code> file into our container application directory. This can be done with the <code>ADD</code> command by passing the <code>package.json</code> and application directory <code>/app</code> as arguments. Once that file has been copied, it's time to install the dependencies. To run commands through the build process of the application we use the <code>RUN</code> command. The command is no different than the one you'd use on your local machine. Therefore, to install the dependencies defined in the <code>package.json</code> file we use the command <code>RUN npm install</code>.</p>
<h3>Copy Application Files</h3>
<p>Once our dependencies are installed, we need to copy the rest of the files in our local project directory to our container application directory. Like with the <code>package.json</code> file we use the <code>ADD</code> command and pass <code>.</code> and <code>/app</code> as our source and destination arguments respectively.</p>
<h4>.dockerignore</h4>
<p>Something to keep in mind is that locally we have a <code>node_modules</code> directory containing our installed dependencies. In the previous step, we ran the <code>npm install</code> command which will create the <code>node_modules</code> directory inside our container. Therefore, there is no need to copy all these files over. Like <code>git</code>, we can set up a <code>.dockerignore</code> file which will contain the files and directory to be ignored by <code>Docker</code> when packaging and building the container. The <code>.dockerignore</code> file looks like the following.</p>
<pre><code class="language-text">node_modules/*
</code></pre>
<h3>Opening Ports</h3>
<p>Our application will be listening for connections on a port. This particular application will use port 3000. We need to define the port to listen on in the <code>Dockerfile</code> as well. To do so, we'll use the <code>EXPOSE</code> command and pass the port(s) that the application will listen on. (MongoDB listens on 27017, but since the <code>Dockerfile</code> only deals with the web application and not the database we only need to specify the web application's port).</p>
<h3>Starting the Application</h3>
<p>After our container is set up, dependencies are installed and port is defined, it's time to start our application. Unlike the process of running commands while building the container using the <code>RUN</code> command, we'll use the <code>CMD</code> command to start our application. The arguments accepted by this are an array of strings. In this case, we start our application like we would locally by typing in <code>npm start</code>. The <code>Dockerfile</code> command to start our application is the following <code>CMD ['npm','start']</code>.</p>
<h2>The docker-compose.yml File</h2>
<pre><code class="language-yaml">version: '2'
services:
  db:
    image: mongo
    ports: 
      - 27017:27017
  web:
    build: .
    ports:
      - 3000:3000
    links:
      - &quot;db&quot;
</code></pre>
<p>The <code>docker-compose.yml</code> file is a way of defining, building and starting multi-container applications using <code>docker-compose</code>. In our case we have a two container application, one of the containers is the web application we defined and built in the <code>Dockerfile</code> and the other is a <code>MongoDB</code> database. The <code>docker-compose.yml</code> file can take many options, but the only ones we'll be using are the <code>version</code> and <code>services</code> option. The <code>version</code> option defines which syntax version of the <code>docker-compose.yml</code> file we'll be using. In our case we'll be using version 2. The <code>services</code> option defines the individual containers to be packaged and initialized.</p>
<h3>Services</h3>
<p>As mentioned, we have two containers. The names of our containers are <code>web</code> and <code>db</code>. These names can be anything you want, as long as they're descriptive and make sense to you. The <code>web</code> container will be our web application and the <code>db</code> container will be our <code>MongoDB</code> database. Notice that we have listed our <code>db</code> service first and then our <code>web</code> service. The reason for this is we want to build and initialize our database prior to our application so that by the time that the web application is initialized, it's able to successfully connect to the database. If done the other way around, an error will be thrown because the database will not be listening for connections and the web application won't be able to connect. Another way to ensure that our database is initialized prior to our web application is to use the <code>links</code> option in our <code>web</code> service and add the name of the database service <code>db</code> to the list of dependent services. The <code>ports</code> option like in our <code>Dockerfile</code> defines which ports that container will need to operate. In this case, our <code>web</code> app listens on port 3000 and the <code>db</code> service will listen on port 27017.</p>
<h4>Container Images</h4>
<p>The <code>docker-compose.yml</code> can build containers based on images hosted in a registry as well as those defined by a <code>Dockerfile</code>. To use images from a registry, we use the <code>image</code> option inside of our service. Take the <code>db</code> service for example. <code>MongoDB</code> already has an image in the <code>DockerHub</code> registry which we will use to build the container. Our <code>web</code> container does not have an image that is listed in a registry. However, we can still build an image based off a <code>Dockerfile</code>. To do this, we use the <code>build</code> option inside our service and pass the directory of the respective <code>Dockerfile</code> containing the build instructions for the container.</p>
<h2>Building and Running Containers</h2>
<p>Now that our container definitions and files are set up, we're ready to build and run our application. This can be done by typing <code>docker-compose up -d</code> in the terminal from inside our local project directory. The <code>-d</code> option runs the command detached allowing us to continue using the terminal. This command will both build and start our containers simultaneously. Once the <code>web</code> and <code>db</code> containers are up and running, we can visit <code>http://localhost:3000</code> from our browser to view and test our application. To stop the application, inside the local project directory, we can type <code>docker-compose stop</code> in our terminal to stop both containers.</p>
<h2>Conclusion</h2>
<p>This writeup uses a pre-configured MEAN stack CRUD todo application and explores how to define a single container <code>Dockerfile</code> as well as a multi-container application using <code>docker-compose</code>. Docker streamlines how applications are built and deployed while <code>docker-compose</code> allows more complex multi-container applications to be orchestrated, linked, deployed and managed simultaneously allowing developers to spend more time  developing solutions and less time managing infrastructure and dependencies.</p>
<h6>Links/Resources</h6>
<p><a href="https://www.docker.com/community-edition#/download">Docker Community Edition</a><br />
<a href="https://docs.docker.com/get-started/">Docker: Getting Started</a><br />
<a href="https://nodejs.org/en/">NodeJS</a></p>
</div></main><script src="/js/jquery.slim.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/highlight.min.js"></script><script src="/js/highlight.fsharp.min.js"></script><script type="application/javascript">hljs.initHighlightingOnLoad();</script></body></html>