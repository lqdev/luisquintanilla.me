<!DOCTYPE html>
<html lang="en"><head><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/bootstrap-icons-1.5.0/bootstrap-icons.css"><link rel="stylesheet" href="/css/highlight-dark.min.css"><link rel="stylesheet" href="/css/main.css"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta property="og:title" content="Operationalizing Machine Learning with ML.NET, Azure DevOps and Azure Container Instances"><meta property="og:type" content="website"><meta property="og:image" content="https://www.luisquintanilla.me/avatar.png"><meta property="og:image:secure_url" content="https://www.luisquintanilla.me/avatar.png"><meta property="og:image:type" content="image/png"><meta property="og:image:width" content="200"><meta property="og:image:height" content="200"><meta property="og:site_name" content="Luis Quintanilla Personal Website"><meta property="og:locale" content="en_US"><meta property="twitter:image" content="https://www.luisquintanilla.me/avatar.png"><meta name="robots" content="noindex,nofollow,nosnippet"><title>Operationalizing Machine Learning with ML.NET, Azure DevOps and Azure Container Instances</title></head><body><nav class="navbar navbar-expand-md navbar-dark fixed-top bg-dark"><a class="navbar-brand" href="#"><img src="/avatar.png" height="32" width="32" class="d-inline-block align-top rounded-circle" style="margin-right:5px">Luis Quintanilla</a><button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarCollapse"><ul class="navbar-nav mr-auto"><li class="nav-item active"><a class="nav-link" href="/">Home</a></li><li class="nav-item"><a class="nav-link" href="/about.html">About</a></li><li class="nav-item"><a class="nav-link" href="/contact.html">Contact</a></li><li class="nav-item"><a class="nav-link" href="/posts/1">Blog</a></li><li class="nav-item"><a class="nav-link" href="/events.html">Events</a></li></ul><a href="/feed.rss"><svg class="bi bi-rss text-secondary" fill="currentColor" viewBox="0 0 16 16" height="32" width="32"><path d="M14 1a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h12zM2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z"></path><path d="M5.5 12a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0zm-3-8.5a1 1 0 0 1 1-1c5.523 0 10 4.477 10 10a1 1 0 1 1-2 0 8 8 0 0 0-8-8 1 1 0 0 1-1-1zm0 4a1 1 0 0 1 1-1 6 6 0 0 1 6 6 1 1 0 1 1-2 0 4 4 0 0 0-4-4 1 1 0 0 1-1-1z"></path></svg></a></div></nav><main role="main" class="container"><div class="mr-auto"><h2>Introduction</h2>
<p>Azure DevOps, formerly known as Visual Studio Team Services (VSTS), helps individuals and organizations plan, collaborate and ship products faster. One if its noteworthy services, Azure Pipelines, helps developers build Continuous Integration (CI) and Continuous Delivery (CD) pipelines that automate and standardize the build, test and deploy phases of the software development process. In addition, Azure Pipelines provides native container support and works with any language, platform and cloud. Machine learning like software development is also a process that includes a build, test and deploy phase which makes it a good candidate for automation and standardization. At Build 2018, Microsoft announced <a href="https://github.com/dotnet/machinelearning">ML.NET</a>, an open-source, cross-plaform machine learning framework for .NET. If we were to put all of these tools and services together, it means that we can automate and standardize the training of a machine learning model built with ML.NET, package it into a Docker container and deploy it to Azure Container Instances (ACI). In this writeup, I will go through the process of building a CI/CD pipeline in Azure Devops that trains, packages and deploys an ML.NET machine learning model to predict which class an Iris flower belongs to using a variety of measurements. Source code for this project can be found at this <a href="https://github.com/lqdev/mlnetazdevopssample">link</a>.</p>
<h2>Prerequisites</h2>
<ul>
<li><a href="https://git-scm.com/">Git</a></li>
<li><a href="https://github.com/">GitHub Account</a></li>
<li><a href="https://www.microsoft.com/net/download">.NET Core SDK</a></li>
<li><a href="https://azure.microsoft.com/en-us/free/">Azure Account</a></li>
</ul>
<h2>The Application</h2>
<p>Because the purpose of this post is to demonstrate the functionality of Azure Devops and not that of ML.NET, I'll start with a pre-built application. For some more information and detail into the functionality of ML.NET, check out the official documentation <a href="https://docs.microsoft.com/en-us/dotnet/machine-learning/">page</a> as well as some of my previous posts:</p>
<ul>
<li><a href="http://luisquintanilla.me/2018/08/21/serverless-machine-learning-mlnet-azure-functions/">Serverless Machine Learning with ML.NET and Azure Functions</a></li>
<li><a href="http://luisquintanilla.me/2018/05/11/deploy-netml-docker-aci/">Deploy .NET Machine Learning Models with ML.NET, ASP.NET Core, Docker and Azure Container Instances</a>.</li>
</ul>
<p>The application used in this writeup contains three .NET Core projects within it. One is a class library which is what we'll use to wrap ML.NET functionality for training models as well as loading pre-trained models that will then be used to make predictions. Another is a .NET Core console application which references the class library to train and persist an ML.NET model. Finally, there's the ASP.NET Core Web API which also references the class library application to load the pre-trained model created by the console application and then makes predictions via HTTP. This application can be utilized and deployed standalone but in this writeup it will be packaged into a Docker image that will then be deployed to Azure Container Instances.</p>
<p><img src="/images/azdevops-mlnet-1.png" alt="" /></p>
<h3>Class Library</h3>
<p>The class library can be found in the <code>MLModel</code> directory. The class library defines the observation and prediction data classes which can be found in the <code>IrisData.cs</code> and <code>IrisPrediction.cs</code> files respectively. Additionally, the <code>Model</code> class contains helper methods that train and save machine learning models, load pre-trained models and use these models to make predictions.</p>
<h3>Console Application</h3>
<p>In the solution directory we also have a console application in the <code>ModelTrainer</code> directory. This application references the class library in the <code>MLModel</code> directory to train and persist the machine learning model.</p>
<h3>API</h3>
<p>The <code>ModelApi</code> directory contains an ASP.NET Core Web API application that references the <code>MLModel</code> class library project to load the pre-trained model that is trained by the <code>ModelTrainer</code> console application and makes predictions via HTTP. The logic for making predictions can be found in the <code>PredictController.cs</code> class in the <code>Controllers</code> directory of the <code>ModelApi</code> application.</p>
<h2>CI/CD Pipeline Flow</h2>
<p>Conceptually, when the application is built and deployed manually, the machine learning model is defined and developed inside the <code>MLModel</code> class library. Once satisfied with the model, the class library is built. The console application which references the <code>MLModel</code> class library is built as well as run to train and persist a classification model in a file called <code>model.zip</code>. The <code>MLModel</code> class library is also referenced in the <code>ModelApi</code> ASP.NET Core project. Because <code>ModelApi</code> is the application we're looking to deploy in order to expose our pre-trained machine learning model, we need to find a way to package it for deployment. We'll be deploying <code>ModelApi</code> using Azure Container Instances which means we need to create a Docker image of the project that will then be pushed to a Docker registry where it will be made available for public consumption. The building of multiple projects as well as the building, publishing and deployment of the Docker image to Azure Container Instances can be standardized and automated using Azure DevOps. The rest of this write-up will focus on demonstrating step-by-step how to operationalize this machine learning application via CI/CD pipelines in Azure DevOps using Azure Pipelines.</p>
<h3>Getting The Code</h3>
<p>Before getting started, the first thing you'll want to do is fork the <a href="https://github.com/lqdev/mlnetazdevopssample">mlnetazdevopssample</a> GitHub repository into your own GitHub account.</p>
<p><img src="/images/azdevops-mlnet-2.png" alt="" /></p>
<h3>Creating the Project</h3>
<p>Navigate to <a href="https://devops.azure.com">https://devops.azure.com</a>, click <code>Start Free</code> and follow the prompts to either create a new account or sign into your existing account.</p>
<p><img src="/images/azdevops-mlnet-3.png" alt="" /></p>
<p>Once logged in, click <code>Create Project</code>.</p>
<p><img src="/images/azdevops-mlnet-4.png" alt="" /></p>
<p>Enter the name of your project as well as a short description. Then, click <code>Create</code>.</p>
<p><img src="/images/azdevops-mlnet-5.png" alt="" /></p>
<h2>The Continuous Integration (CI) Pipeline</h2>
<p>Using Azure Pipelines, we'll configure a CI pipeline for the build and packaging steps of our application. Below is an illustration of all the steps involved in our CI pipeline:</p>
<p><img src="/images/azdevops-mlnet-6.png" alt="" /></p>
<ol>
<li>Build the class library application</li>
<li>Build the console application</li>
<li>Train and persist the ML.NET Model by running the console application.</li>
<li>Copy ML.NET model file created by console application into ASP.NET Core Web API application directory</li>
<li>Build ASP.NET Core Web API application</li>
<li>Build Docker image</li>
<li>Push Docker image to Docker Hub</li>
</ol>
<h3>CI Pipeline Setup</h3>
<p>Once the project is created, in the main project page, hover over <code>Pipelines</code> and click on <code>Builds</code>.</p>
<p><img src="/images/azdevops-mlnet-7.png" alt="" /></p>
<p>In the <code>Builds</code> pipeline page, click <code>New pipeline</code>.</p>
<p><img src="/images/azdevops-mlnet-8.png" alt="" /></p>
<p>Select GitHub as the source and connect your GitHub account with Azure DevOps.</p>
<p><img src="/images/azdevops-mlnet-9.png" alt="" /></p>
<p>Once you have authorized Azure DevOps to use your GitHub account, select the repository and branch that will be used for this build pipeline. In our case, we'll be using the master branch of the <code>mlnetazdevopssample</code> repository. When finished configuring, click <code>Continue</code>.</p>
<p><img src="/images/azdevops-mlnet-10.png" alt="" /></p>
<p>The next step will be to select the jobs to execute in our pipeline. Because there are multiple steps in this build pipeline, let's start with an <code>Empty Job</code> and customize it to our needs.</p>
<p><img src="/images/azdevops-mlnet-11.png" alt="" /></p>
<p>From inside the build pipeline page, before we start adding jobs, lets select the agent that will execute the jobs. For this pipeline, select the <code>Hosted Ubuntu 1604</code> option from the dropdown.</p>
<p><img src="/images/azdevops-mlnet-12.png" alt="" /></p>
<h3>1. Build the Class Library Application</h3>
<p>The first step in our CI Pipeline will be to build our class library which contains methods that wrap the training, loading and prediction functionality of the ML.NET framework and persisted models.</p>
<p>To achieve that, we'll add a .NET Core task to our <code>Agent Job 1</code>.</p>
<p><img src="/images/azdevops-mlnet-13.png" alt="" /></p>
<p>Once added to the pipeline, let's configure this task. To make it more descriptive, we can give it a name such as <code>Build Class Library</code>. Because this task will be responsible for building the .NET Core class library, we'll leave the default <code>build</code> Command setting as is.</p>
<p><img src="/images/azdevops-mlnet-14.png" alt="" /></p>
<p>The other setting we'll want to configure is the <code>Working Directory</code>. We can do so by clicking the <code>Advanced</code> tab.</p>
<p><img src="/images/azdevops-mlnet-15.png" alt="" /></p>
<p>For this task we'll use the <code>MLModel</code> directory.</p>
<p><img src="/images/azdevops-mlnet-16.png" alt="" /></p>
<p>When finished with the configuration, click <code>Save &amp; Queue</code> -&gt; <code>Save</code> on the top toolbar.</p>
<p><img src="/images/azdevops-mlnet-17.png" alt="" /></p>
<p>Enter a detailed comment describing the change to the pipeline and click <code>Save</code>.</p>
<p><img src="/images/azdevops-mlnet-18.png" alt="" /></p>
<h3>2. Building The Console Application</h3>
<p>Once we've built the class library application which we'll reference from the .NET Core console and ASP.NET Core Web API applications, it's time to build the console application which will serve the purpose of training and persisting the ML.NET model.</p>
<p>Similar to the previous step, add a new .NET Core <em>build</em> task to the pipeline. The only setting that will change for this task is the <code>Working Directory</code> which will have the value of <code>ModelTrainer</code>.</p>
<p><img src="/images/azdevops-mlnet-19.png" alt="" /></p>
<p>Although not required, when finished configuring the task, click <code>Save &amp; Queue</code> -&gt; <code>Save</code> to save and comment the changes to the pipeline.</p>
<h3>3. Train and persist the ML.NET Model</h3>
<p>Now that our console application is built, it's time to run it in order to train and persist the ML.NET model. To do so, we'll add another .NET Core task. The difference is that the <code>Command</code> setting will now be configured with the <code>run</code> value.</p>
<p><img src="/images/azdevops-mlnet-20.png" alt="" /></p>
<p>The <code>Working Directory</code> will be set to <code>ModelTrainer</code> like in the previous task.</p>
<p><img src="/images/azdevops-mlnet-21.png" alt="" /></p>
<p>Remember to save and comment the new changes to the pipeline.</p>
<h3>4. Copy ML.NET Model to Web API Directory</h3>
<p>After the console application is run and the ML.NET model is trained, it is persisted in a file called <code>model.zip</code> inside the <code>ModelTrainer</code> directory. We can use this persisted version of the model to make predictions from both the console application or any other application of our choice. In this case, we'll be making predictions via an ASP.NET Core Web API. In order for our API to reference this file, we need to copy it into the root directory of our <code>ModelApi</code> directory. A way to perform that task is via bash script. To add a bash script to our pipeline, all we need to do is add a Bash task to it.</p>
<p><img src="/images/azdevops-mlnet-22.png" alt="" /></p>
<p>Once added to our pipeline, it's time to configure the task. We'll set the <code>Type</code> setting to <code>Inline</code> which will bring up a text box for us to type in the script.</p>
<p><img src="/images/azdevops-mlnet-23.png" alt="" /></p>
<p>Inside of the text box, enter the following content:</p>
<pre><code class="language-bash"># Write your commands here

cp ../ModelTrainer/model.zip .

# Use the environment variables input below to pass secret variables to this script
</code></pre>
<p>This command will copy the <code>model.zip</code> file from the <code>ModelTrainer</code> directory to the <code>ModelApi</code> directory.</p>
<p>We can set the <code>Working Directory</code> of this step to <code>ModelApi</code>.</p>
<p><img src="/images/azdevops-mlnet-24.png" alt="" /></p>
<p>Once finished, save and comment the new changes to the pipeline.</p>
<h3>5. Build ASP.NET Core Web API application</h3>
<p>Now that we have the necessary files inside our <code>ModelApi</code> application, it's time to build it. We'll add a .NET Core task to our pipeline and set the <code>Command</code> to <code>build</code>. The <code>Working Directory</code> will be <code>ModelApi</code> like the previous task.</p>
<p>Save and comment the new changes to the pipeline when finished.</p>
<p><img src="/images/azdevops-mlnet-25.png" alt="" /></p>
<h3>6. Build ASP.NET Core Web API Docker Image</h3>
<p>The method of deployment for the ASP.NET Core Web API application is via containers. Therefore, after building the application, we have to build a Docker image for it that can then be pushed to a Docker registry of your choice. To build a Docker image, we'll add a Docker task to our pipeline.</p>
<p><img src="/images/azdevops-mlnet-26.png" alt="" /></p>
<p>When we configure the task, we'll start off by setting the <code>Container Registry Type</code> to <code>Container Registry</code>.</p>
<p><img src="/images/azdevops-mlnet-27.png" alt="" /></p>
<p>This will prompt the setup of a service connection to a Docker registry if one does not already exist.</p>
<p><img src="/images/azdevops-mlnet-28.png" alt="" /></p>
<p>The Docker registry type we'll be using is Docker Hub. Give the connection a name, enter the credentials to your Docker Hub account and click <code>Verify this connection</code> to make sure that your credentials are valid and a connection can be established with Docker Hub. When finished click <code>OK</code>.</p>
<p><img src="/images/azdevops-mlnet-29.png" alt="" /></p>
<p>The <code>Command</code> setting will be <code>build</code> so we can leave the default as is as well as the <code>Dockerfile</code> setting which will use the Dockerfile in the root <code>mlnetazdevopssample</code> directory.</p>
<p><img src="/images/azdevops-mlnet-30.png" alt="" /></p>
<p>Finally, we'll configure the <code>Image name</code> setting. The convention we'll use is <code>&lt;docker-hub-username&gt;/&lt;image-name&gt;</code>. In my case, <code>lqdev</code> is my Docker Hub username and I'll name my image <code>mlnetazdevopssample</code> resulting in <code>lqdev/mlnetazdevopssample</code>. Additionally, check the <code>Include latest tag</code> checkbox to have every build be the latest as opposed to tagging it with versions numbers.</p>
<p><img src="/images/azdevops-mlnet-31.png" alt="" /></p>
<p>Remember to save and comment the recent changes to the pipeline.</p>
<h3>7. Push Docker Image to Docker Hub</h3>
<p>The last step in our CI pipeline is to push our newly built image to Docker Hub. To do so we'll use anoter Docker task.</p>
<p><img src="/images/azdevops-mlnet-32.png" alt="" /></p>
<p>Like in the previous task, we'll set the <code>Container registry type</code> to <code>Container Registry</code>. Set the <code>Docker registry service connection</code> to the most recently created connection by selecting it from the dropdown. We'll be changing our <code>Command</code> to <code>push</code> and set the <code>Image name</code> to the name of the image built in the previous step. The naming convention is <code>&lt;docker-hub-username&gt;/&lt;image-name&gt;:latest</code>. The latest tag was added by our previous Docker build task so make sure that you include it in this task.</p>
<p>Once finished, click <code>Save &amp; Queue</code> -&gt; <code>Save &amp; Queue</code>. As opposed to only clicking <code>Save</code>, this action will manually trigger the CI pipeline.</p>
<p><img src="/images/azdevops-mlnet-33.png" alt="" /></p>
<p>Don't forget to comment your changes and click <code>Save &amp; queue</code> to kick off the CI pipeline.</p>
<p><img src="/images/azdevops-mlnet-34.png" alt="" /></p>
<h3>Monitoring the Build</h3>
<p>When the build starts, you can click on <code>Builds</code> under the <code>Pipelines</code> section on the left pane.</p>
<p><img src="/images/azdevops-mlnet-35.png" alt="" /></p>
<p>Select the first build from the list to get more details on the build.</p>
<p><img src="/images/azdevops-mlnet-36.png" alt="" /></p>
<p>This will take you to the logs which show the status of the pipeline near real-time.</p>
<p><img src="/images/azdevops-mlnet-37.png" alt="" /></p>
<h3>Confirming CI Pipeline Success</h3>
<p>If the build is successful, navigate to <a href="https://hub.docker.com/">https://hub.docker.com/</a> to check whether the Docker image was pushed to the registry.</p>
<p><img src="/images/azdevops-mlnet-38.png" alt="" /></p>
<h2>The Continuous Delivery (CD) Pipeline</h2>
<p>Now that we have our CI pipeline set up which will build and package our application, it's time to deploy it. We could do this ourselves or automate it using a CD pipeline. Our application wil be deployed to Azure Container Instances which is an Azure service that offers a quick way to run containers without having to worry about the management of virtual machines or orchestration services. The steps involved in our CD pipeline are the following:</p>
<ol>
<li>Create Azure Resource Group for deployment</li>
<li>Deploy application to Azure Container Instances.</li>
</ol>
<h3>CD Pipeline Setup</h3>
<p>To get started setting up a CD pipeline, from the Azure DevOps project main page, hover over <code>Pipelines</code> and click on <code>Releases</code>.</p>
<p><img src="/images/azdevops-mlnet-39.png" alt="" /></p>
<p>Once in that page, click on <code>New pipeline</code>.</p>
<p><img src="/images/azdevops-mlnet-40.png" alt="" /></p>
<p>As with our CI pipeline, we'll start off with an <code>Empty Job</code> which we'll configure at a later time.</p>
<p><img src="/images/azdevops-mlnet-41.png" alt="" /></p>
<h3>Triggering Deployments</h3>
<p>Once our pipeline is created, it's time to configure it. The first thing we'll want to do is add an artifact. An artifact can be a variety of things including the output of our build pipeline. In our case, the end our CI pipeline will be the trigger for our CD pipeline. To add an artifact, click <code>Add an artifact</code>.</p>
<p><img src="/images/azdevops-mlnet-42.png" alt="" /></p>
<p>In the configuration form, set the <code>Source type</code> to <code>Build</code> and the <code>Source</code> to the name of the CI pipeline created in the previous steps. When finished, click <code>Add</code>.</p>
<p><img src="/images/azdevops-mlnet-43.png" alt="" /></p>
<p>After configuring our artifact, it's time to configure the steps in the CD pipeline. To do so, click on the <code>Stage 1</code> option in the <code>Stages</code> section of the release pipeline page and change the name to something more descriptive.</p>
<p><img src="/images/azdevops-mlnet-44.png" alt="" /></p>
<p>When finished, close out the form and click on the hyperlink below the stage title.</p>
<p><img src="/images/azdevops-mlnet-45.png" alt="" /></p>
<p>You should now be on a page similar to the CI pipeline job configuration page. On this page, we'll want to click on the <code>Agent Job</code> panel to set the <code>Agent pool</code> setting to <code>Hosted Ubuntu 1604</code>.</p>
<p><img src="/images/azdevops-mlnet-46.png" alt="" /></p>
<p>Once that is complete, it's time to configure the tasks in the CD pipeline.</p>
<h3>1. Create Azure Resource Group</h3>
<p>Start off adding an <code>Azure CLI</code> task to the pipeline. In this task we'll create a resource group in Azure to which we'll deploy our application to.</p>
<p><img src="/images/azdevops-mlnet-47.png" alt="" /></p>
<p>Before doing anything else, link DevOps to an Azure Subscription by selecting one from the dropdown and clicking <code>Authorize</code> which will prompt you to authenticate your subscription.</p>
<p><img src="/images/azdevops-mlnet-48.png" alt="" /></p>
<p>Once an Azure subscription has been linked, let's change the <code>Script Location</code> setting to <code>Inline Script</code>.</p>
<p><img src="/images/azdevops-mlnet-49.png" alt="" /></p>
<p>In the <code>Inline Script</code> text box enter the following:</p>
<pre><code class="language-bash">az group create --name mlnetazdevopssampleresourcegroup --location eastus
</code></pre>
<p>This script will create a resource group in Azure called <code>mlnetazdevopssampleresourcegroup</code> that is located in <code>eastus</code>. Both of these are configurable to your preference.</p>
<h3>2. Deploy Docker Image to Azure Container Instances</h3>
<p>The next and final step in our CD pipeline is the deployment to Azure Container Instances. To deploy our application, we'll add another <code>Azure CLI</code> task. This time, since we already configured our <code>Azure subscription</code> in the previous task, we can select the service connection as opposed to a subscription from the dropdown.</p>
<p><img src="/images/azdevops-mlnet-50.png" alt="" /></p>
<p>Like in the previous task, our script will be inline.</p>
<p><img src="/images/azdevops-mlnet-51.png" alt="" /></p>
<p>In the <code>Inline Script</code> text box enter the following:</p>
<pre><code class="language-bash">az container create --resource-group mlnetazdevopssampleresourcegroup --name mlnetcontainer --image lqdev/mlnetazdevopssample:latest --ports 80 --ip-address public
</code></pre>
<p>This script creates a container in the resource group created by the previous task of the pipeline with the name <code>mlnetcontainer</code> from the Docker image that was pushed to Docker Hub by the CI pipeline. Additionally, it opens up port 80 and assigns a publicly accessible IP address for the container to be accessed externally.</p>
<p>Once this step has been configured, make sure to save and comment all your changes by clicking <code>Save</code>.</p>
<p><img src="/images/azdevops-mlnet-52.png" alt="" /></p>
<p><img src="/images/azdevops-mlnet-53.png" alt="" /></p>
<p>Then, to make it easily recognizable, edit the name of the pipeline by hovering near <code>New release pipeline</code> and clicking on the pencil icon.</p>
<p><img src="/images/azdevops-mlnet-54.png" alt="" /></p>
<p>Make sure to save and comment your changes.</p>
<h2>Automating CI/CD Pipelines</h2>
<p>In the previous steps, we configured CI and CD pipelines. However, we have still not fully automated the triggers that kick off both of these.</p>
<h3>CI Pipeline Trigger</h3>
<p>First, lets start off by automating the CI pipeline. To do so, go the project's main page, hover over <code>Pipelines</code> and click on <code>Builds</code>.</p>
<p><img src="/images/azdevops-mlnet-55.png" alt="" /></p>
<p>This will take you to the CI pipeline page. While on this page, click <code>Edit</code>.</p>
<p><img src="/images/azdevops-mlnet-56.png" alt="" /></p>
<p>Then, click on <code>Triggers</code>.</p>
<p><img src="/images/azdevops-mlnet-57.png" alt="" /></p>
<p>Once on this page, check the <code>Enable continous integration</code> checkbox and save and comment your changes by clicking <code>Save &amp; Queue</code> -&gt; <code>Save</code>.</p>
<p><img src="/images/azdevops-mlnet-58.png" alt="" /></p>
<h3>CD Pipeline Trigger</h3>
<p>To automate the CD pipeline trigger, click on <code>Releases</code> under the <code>Pipelines</code> page to automate the CD pipeline.</p>
<p><img src="/images/azdevops-mlnet-59.png" alt="" /></p>
<p>Once on the CD pipeline's page, click <code>Edit</code>.</p>
<p><img src="/images/azdevops-mlnet-60.png" alt="" /></p>
<p>Then, click on the lightning icon in the Artifacts section which will show a configuration form. In this form, toggle the <code>Continuous deployment trigger</code> setting to <code>Enabled</code>.</p>
<p><img src="/images/azdevops-mlnet-61.png" alt="" /></p>
<p>When finished, save and comment your changes.</p>
<h2>Running CI/CD Pipelines</h2>
<p>Although going forward builds and deployments will be started when new changes are checked into the master branch of the <code>mlnetazdevopssample</code> repository, for demonstration purposes we will manually kick off the CI/CD pipelines we have just configured. To do so, click on <code>Builds</code> under the <code>Pipelines</code> section on the left pane.</p>
<p><img src="/images/azdevops-mlnet-62.png" alt="" /></p>
<p>From the CI pipeline page click <code>Queue</code>.</p>
<p><img src="/images/azdevops-mlnet-63.png" alt="" /></p>
<p>This will prompt a modal to show up in which you can just click <code>Queue</code> to start the build.</p>
<p><img src="/images/azdevops-mlnet-64.png" alt="" /></p>
<p>This will kick off a new CI build which subsequently will also kick off the CD pipeline of your application.</p>
<h2>Testing The Deployment</h2>
<p>If all is successful, a Docker image of an ASP.NET Core Web API application will be deployed to Azure Container Instances which can be accessed via a public IP address.</p>
<p>To see whether the deployment worked, navigate to <a href="https://portal.azure.com/">https://portal.azure.com/</a> and click on <code>Resource groups</code>.</p>
<p><img src="/images/azdevops-mlnet-65.png" alt="" /></p>
<p>At this point, you should see the resource group that was created by the CD pipeline. If that's the case, click on it.</p>
<p><img src="/images/azdevops-mlnet-66.png" alt="" /></p>
<p>This will then show a page that displays the container that was deployed to this resource group. Click on that.</p>
<p><img src="/images/azdevops-mlnet-67.png" alt="" /></p>
<p>The container page will display diagnostic and configuration information about the container. The information we're interested in is the <code>IP address</code>. Hover to the right of it and click on the icon that says <code>Click to copy</code>. This will copy the address to the clipboard.</p>
<p><img src="/images/azdevops-mlnet-68.png" alt="" /></p>
<p>In an application like Postman or Insomnia, make an HTTP POST request to <code>http://&lt;ip-address&gt;/api/predict</code> where <code>ip-address</code> is the public IP address of the container in Azure with the following body.</p>
<pre><code class="language-json">{
    &quot;SepalLength&quot;:3.3,
    &quot;SepalWidth&quot;:1.6,
    &quot;PetalLength&quot;:0.2,
    &quot;PetalWidth&quot;:5.1
}
</code></pre>
<p>If successful, the response will be <code>Iris-virginica</code>.</p>
<p><img src="/images/azdevops-mlnet-69.png" alt="" /></p>
<h2>Conclusion</h2>
<p>In this writeup, we operationalized the building, packaging and deployment of an ML.NET application that predicts the class of an Iris flower using a variety of mesurements with Azure DevOps. We created both a Continous Integration as well as a Continous Delivery pipeline which deploys the Docker image of an ASP.NET Core Web API to Azure Container Instances. Keep in mind this is just one way of doing it and Azure DevOps is flexible in how all of these tasks and workflows are configured to meet your requirements. Happy coding!</p>
<h6>Resources</h6>
<p><a href="https://github.com/dotnet/machinelearning-samples">ML.NET Samples</a>
<a href="https://www.youtube.com/watch?v=bUTBBS1TECc">DevOps for Data Science</a></p>
</div></main><script src="/js/jquery.slim.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/highlight.min.js"></script><script src="/js/highlight.fsharp.min.js"></script><script type="application/javascript">hljs.initHighlightingOnLoad();</script></body><footer><a rel="me" href="https://toot.lqdev.tech/@lqdev"></a></footer></html>