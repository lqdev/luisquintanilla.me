<!DOCTYPE html>
<html lang="en"><head><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/bootstrap-icons-1.5.0/bootstrap-icons.css"><link rel="stylesheet" href="/css/highlight-dark.min.css"><link rel="stylesheet" href="/css/main.css"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta charset="UTF-8"><meta property="og:title" content="Deploy .NET Machine Learning Models with ML.NET, ASP.NET Core, Docker and Azure Container Instances - Luis Quintanilla"><meta property="og:type" content="website"><meta property="og:image" content="https://www.luisquintanilla.me/avatar.png"><meta property="og:image:secure_url" content="https://www.luisquintanilla.me/avatar.png"><meta property="og:image:type" content="image/png"><meta property="og:image:width" content="200"><meta property="og:image:height" content="200"><meta property="og:site_name" content="Luis Quintanilla Personal Website"><meta property="og:locale" content="en_US"><meta property="twitter:image" content="https://www.luisquintanilla.me/avatar.png"><meta name="robots" content="noindex,nofollow,nosnippet"><title>Deploy .NET Machine Learning Models with ML.NET, ASP.NET Core, Docker and Azure Container Instances - Luis Quintanilla</title></head><body><nav class="navbar navbar-expand-md navbar-dark fixed-top bg-dark"><a class="navbar-brand" href="/"><img src="/avatar.png" height="32" width="32" class="d-inline-block align-top rounded-circle" style="margin-right:5px">Luis Quintanilla</a><button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarCollapse"><ul class="navbar-nav mr-auto"><li class="nav-item active"><a class="nav-link" href="/">Home</a></li><li class="nav-item"><a class="nav-link" href="/about.html">About</a></li><li class="nav-item"><a class="nav-link" href="/contact.html">Contact</a></li><li class="nav-item"><a class="nav-link" href="/posts/1">Blog</a></li><li class="nav-item"><a class="nav-link" href="/events.html">Events</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Feeds</a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/feed/index.html">Main</a><a class="dropdown-item" href="/feed/notes.html">Notes</a><a class="dropdown-item" href="/feed/videos.html">Videos</a><div class="dropdown-divider"></div><a class="dropdown-item" href="/feed/blogroll.html">Blogroll</a></div></li></ul><a href="/about.html#subscribe"><svg class="bi bi-rss text-secondary" fill="currentColor" viewBox="0 0 16 16" height="32" width="32"><path d="M14 1a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h12zM2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z"></path><path d="M5.5 12a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0zm-3-8.5a1 1 0 0 1 1-1c5.523 0 10 4.477 10 10a1 1 0 1 1-2 0 8 8 0 0 0-8-8 1 1 0 0 1-1-1zm0 4a1 1 0 0 1 1-1 6 6 0 0 1 6 6 1 1 0 1 1-2 0 4 4 0 0 0-4-4 1 1 0 0 1-1-1z"></path></svg></a></div></nav><main role="main" class="container"><div class="mr-auto"><h1>Introduction</h1>
<p>Leading up to and during MS Build 2018 Microsoft has released a wide range of products that reduce the complexity that comes with building and deploying software. The focus this year was on Machine Learning and Artificial Intelligence. Some of the products I found particularly interesting are <a href="https://azure.microsoft.com/en-us/services/container-instances/">Azure Container Instances</a> which makes it easier to run containerized applications without provisioning or managing servers and <a href="https://www.microsoft.com/net/learn/apps/machine-learning-and-ai/ml-dotnet">ML.NET</a> which is a .NET cross-platform machine learning framework. In this writeup, I will make use of both these products by creating a machine learning classification model with <code>ML.NET</code>, exposing it via an ASP.NET Core Web API, packaging it into a Docker container and deploying it to the cloud via Azure Container Instances. Source code for this project can be found <a href="https://github.com/lqdev/mlnetacidemo">here</a>.</p>
<h2>Prerequisites</h2>
<p>This writeup assumes that you have some familiarity with Docker. The following software/dependencies are also required to build and deploy the sample application. It's important to note the application was built on a Ubuntu 16.04 PC, but all the software is cross-platform and should work on any environment.</p>
<ul>
<li><a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/">Docker</a></li>
<li><a href="https://docs.microsoft.com/en-us/cli/azure/install-azure-cli?view=azure-cli-latest">Azure CLI</a></li>
<li><a href="https://www.microsoft.com/net/download/linux">.NET Core 2.0</a></li>
<li><a href="https://hub.docker.com/">Docker Hub Account</a></li>
</ul>
<h2>Setting Up The Project</h2>
<p>The first thing we want to do is create a folder for our solution.</p>
<pre><code class="language-bash">mkdir mlnetacidemo
</code></pre>
<p>Then, we want to create a solution inside our newly created folder.</p>
<pre><code class="language-bash">cd mlnetacidemo
dotnet new sln
</code></pre>
<h2>Building The Model</h2>
<p>Inside our solution folder, we want to create a new console application which is where we'll build and test our machine learning model.</p>
<h3>Setting Up the Model Project</h3>
<p>First, we want to create the project. From the solution folder enter:</p>
<pre><code class="language-bash">dotnet new console -o model
</code></pre>
<p>Now we want to add this new project to our solution.</p>
<pre><code class="language-bash">dotnet sln mlnetacidemo.sln add model/model.csproj
</code></pre>
<h3>Adding Dependencies</h3>
<p>Since we'll be using the <code>ML.NET</code> framework, we need to add it to our <code>model</code> project.</p>
<pre><code class="language-bash">cd model
dotnet add package Microsoft.ML
dotnet restore
</code></pre>
<h3>Download The Data</h3>
<p>Before we start training the model, we need to download the data we'll be using to train. We do so by creating a directory called <code>data</code> and downloading the data file onto there.</p>
<pre><code class="language-bash">mkdir data
curl -o data/iris.txt https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data
</code></pre>
<p>If we take a look at the data file, it should look something like this:</p>
<pre><code class="language-text">5.1,3.5,1.4,0.2,Iris-setosa
4.9,3.0,1.4,0.2,Iris-setosa
4.7,3.2,1.3,0.2,Iris-setosa
4.6,3.1,1.5,0.2,Iris-setosa
5.0,3.6,1.4,0.2,Iris-setosa
5.4,3.9,1.7,0.4,Iris-setosa
4.6,3.4,1.4,0.3,Iris-setosa
5.0,3.4,1.5,0.2,Iris-setosa
4.4,2.9,1.4,0.2,Iris-setosa
4.9,3.1,1.5,0.1,Iris-setosa
</code></pre>
<h3>Train Model</h3>
<p>Now that we have all our dependencies set up, it's time to build our model. I leveraged the demo that is used on the <a href="https://www.microsoft.com/net/learn/apps/machine-learning-and-ai/ml-dotnet/get-started/linux/ubuntu16-04">ML.NET Getting-Started website</a>.</p>
<h4>Defining Data Structures</h4>
<p>In the root directory of our <code>model</code> project, let's create two classes called <code>IrisData</code> and <code>IrisPrediction</code> which will define our features and predicted attribute respectively. Both of them will use <code>Microsoft.ML.Runtime.Api</code> to add the property attributes.</p>
<p>Here is what our <code>IrisData</code> class looks like:</p>
<pre><code class="language-csharp">using Microsoft.ML.Runtime.Api;

namespace model
{
public class IrisData
    {
        [Column(&quot;0&quot;)]
        public float SepalLength;

        [Column(&quot;1&quot;)]
        public float SepalWidth;

        [Column(&quot;2&quot;)]
        public float PetalLength;
        
        [Column(&quot;3&quot;)]
        public float PetalWidth;

        [Column(&quot;4&quot;)]
        [ColumnName(&quot;Label&quot;)]
        public string Label;
    }       
}
</code></pre>
<p>Similarly, here is the <code>IrisPrediction</code> class:</p>
<pre><code class="language-csharp">using Microsoft.ML.Runtime.Api;

namespace model
{
    public class IrisPrediction
    {
        [ColumnName(&quot;PredictedLabel&quot;)]
        public string PredictedLabels;
    }
}
</code></pre>
<h4>Building Training Pipeline</h4>
<p>The way the <code>ML.NET</code> computations process is via a sequential pipeline of steps that are performed eventually leading up to the training of the model. Therefore, we can create a class called <code>Model</code> to perform all of these tasks for us.</p>
<pre><code class="language-csharp">using Microsoft.ML.Data;
using Microsoft.ML;
using Microsoft.ML.Runtime.Api;
using Microsoft.ML.Trainers;
using Microsoft.ML.Transforms;
using Microsoft.ML.Models;
using System;
using System.Threading.Tasks;

namespace model
{
    class Model
    {
        
        public static async Task&lt;PredictionModel&lt;IrisData,IrisPrediction&gt;&gt; Train(LearningPipeline pipeline, string dataPath, string modelPath)
        {
            // Load Data
            pipeline.Add(new TextLoader(dataPath).CreateFrom&lt;IrisData&gt;(separator:',')); 

            // Transform Data
            // Assign numeric values to text in the &quot;Label&quot; column, because 
            // only numbers can be processed during model training   
            pipeline.Add(new Dictionarizer(&quot;Label&quot;));

            // Vectorize Features
            pipeline.Add(new ColumnConcatenator(&quot;Features&quot;, &quot;SepalLength&quot;, &quot;SepalWidth&quot;, &quot;PetalLength&quot;, &quot;PetalWidth&quot;));

            // Add Learner
            pipeline.Add(new StochasticDualCoordinateAscentClassifier());

            // Convert Label back to text 
            pipeline.Add(new PredictedLabelColumnOriginalValueConverter() {PredictedLabelColumn = &quot;PredictedLabel&quot;});

            // Train Model
            var model = pipeline.Train&lt;IrisData,IrisPrediction&gt;();

            // Persist Model
            await model.WriteAsync(modelPath);

            return model;
        }
    }
}
</code></pre>
<p>In addition to building our pipeline and training our machine learning model, the <code>Model</code> class also serialized and persisted the model for future use in a file called <code>model.zip</code>.</p>
<h4>Testing Our Model</h4>
<p>Now that we have our data structures and model training pipeline set up, it's time to test everything to make sure it's working. We'll put our logic inside of our <code>Program.cs</code> file.</p>
<pre><code class="language-csharp">using System;
using Microsoft.ML;

namespace model
{
    class Program
    {
        static void Main(string[] args)
        {

            string dataPath = &quot;model/data/iris.txt&quot;;

            string modelPath = &quot;model/model.zip&quot;;

            var model = Model.Train(new LearningPipeline(),dataPath,modelPath).Result;

            // Test data for prediction
            var prediction = model.Predict(new IrisData() 
            {
                SepalLength = 3.3f,
                SepalWidth = 1.6f,
                PetalLength = 0.2f,
                PetalWidth = 5.1f
            });

            Console.WriteLine($&quot;Predicted flower type is: {prediction.PredictedLabels}&quot;);
        }
    }
}
</code></pre>
<p>All set to run. We can do so by entering the following command from our solution directory:</p>
<pre><code class="language-bash">dotnet run -p model/model.csproj
</code></pre>
<p>Once the application has been run, the following output should display on the console.</p>
<pre><code class="language-text">Automatically adding a MinMax normalization transform, use 'norm=Warn' or
'norm=No' to turn this behavior off.Using 2 threads to train.
Automatically choosing a check frequency of 2.Auto-tuning parameters: maxIterations = 9998.
Auto-tuning parameters: L2 = 2.667734E-05.
Auto-tuning parameters: L1Threshold (L1/L2) = 0.Using best model from iteration 882.
Not training a calibrator because it is not needed.
Predicted flower type is: Iris-virginica
</code></pre>
<p>Additionally, you'll notice that a file called <code>model.zip</code> was created in the root directory of our <code>model</code> project. This persisted model can now be used outside of our application to make predictions, which is what we'll do next via an API.</p>
<h2>Exposing The Model</h2>
<p>Once a machine learning model is built, you want to deploy it so it can start making predictions. One way to do that is via a REST API. At it's core, all our API needs to do is accept data input from the client and respond back with a prediction. To help us do that, we'll be using an ASP.NET Core API.</p>
<h3>Setting Up The API Project</h3>
<p>The first thing we want to do is create the project.</p>
<pre><code class="language-bash">dotnet new webapi -o api
</code></pre>
<p>Then we want to add this new project to our solution</p>
<pre><code class="language-bash">dotnet sln mlnetacidemo.sln add api/api.csproj
</code></pre>
<h3>Adding Dependencies</h3>
<p>Because we'll be loading our model and making predictions via our API, we need to add the <code>ML.NET</code> package to our <code>api</code> project.</p>
<pre><code class="language-bash">cd api
dotnet add package Microsoft.ML
dotnet restore
</code></pre>
<h3>Referencing Our Model</h3>
<p>In the previous step when we built our machine learning model, it was saved to a file called <code>model.zip</code>. This is the file we'll be referencing in our API to help us make predictions. To reference it in our API, simply copy it from the model project directory into our <code>api</code> project directory.</p>
<h3>Creating Data Models</h3>
<p>Our model was built using data structures <code>IrisData</code> and <code>IrisPrediction</code> to define the features as well as the predicted attribute. Therefore, when our model makes predictions via our API, it needs to reference these data types as well. As a result, we need to define <code>IrisData</code> and <code>IrisPrediction</code> classes inside of our <code>api</code> project. The contents of the classes will be nearly identical to those in the <code>model</code> project with the only exception of our namespace changing from <code>model</code> to <code>api</code>.</p>
<pre><code class="language-csharp">using Microsoft.ML.Runtime.Api;

namespace api
{
    public class IrisData
    {
        [Column(&quot;0&quot;)]
        public float SepalLength;

        [Column(&quot;1&quot;)]
        public float SepalWidth;

        [Column(&quot;2&quot;)]
        public float PetalLength;
        
        [Column(&quot;3&quot;)]
        public float PetalWidth;

        [Column(&quot;4&quot;)]
        [ColumnName(&quot;Label&quot;)]
        public string Label;
    }    
}
</code></pre>
<pre><code class="language-csharp">using Microsoft.ML.Runtime.Api;

namespace api
{
    public class IrisPrediction
    {
        [ColumnName(&quot;PredictedLabel&quot;)]
        public string PredictedLabels;
    }
}
</code></pre>
<h3>Building Endpoints</h3>
<p>Now that our project is set up, it's time to add a controller that will handle prediction requests from the client. In the <code>Controllers</code> directory of our <code>api</code> project we can create a new class called <code>PredictController</code> with a single <code>POST</code> endpoint. The contents of the file should look like the code below:</p>
<pre><code class="language-csharp">using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using Microsoft.ML;

namespace api.Controllers
{
    [Route(&quot;api/[controller]&quot;)]
    public class PredictController : Controller
    {
        // POST api/predict
        [HttpPost]
        public string Post([FromBody] IrisData instance)
        {
            var model = PredictionModel.ReadAsync&lt;IrisData,IrisPrediction&gt;(&quot;model.zip&quot;).Result;
            var prediction = model.Predict(instance);
            return prediction.PredictedLabels;
        }
    }
}
</code></pre>
<h3>Testing The API</h3>
<p>Once our <code>predict</code> endpoint is set up, it's time to test it. From the root directory of our <code>mlnetacidemo</code> solution, enter the following command.</p>
<pre><code class="language-bash">dotnet run -p api/api.csproj
</code></pre>
<p>In a client like POSTMAN or Insomnia, send an HHTP POST request to the endpoint <code>http://localhost:5000/api/predict</code>.</p>
<p>The body our request should look similar to the snippet below:</p>
<pre><code class="language-json">{
	&quot;SepalLength&quot;: 3.3,
	&quot;SepalWidth&quot;: 1.6,
	&quot;PetalLength&quot;: 0.2,
	&quot;PetalWidth&quot;: 5.1,
}
</code></pre>
<p>If successful, the output returned should equal <code>Iris-virginica</code> just like our console application.</p>
<h2>Packaging The Application</h2>
<p>Great! Now that our application is successfully running locally, it's time to package it up into a Docker container and push it to Docker Hub.</p>
<h3>Creating The Dockerfile</h3>
<p>In our <code>mlnetacidemo</code> solution directory, create a <code>Dockerfile</code> with the following content:</p>
<pre><code class="language-Dockerfile">FROM microsoft/dotnet:2.0-sdk AS build
WORKDIR /app

# copy csproj and restore as distinct layers
COPY *.sln .
COPY api/*.csproj ./api/
RUN dotnet restore

# copy everything else and build app
COPY api/. ./api/
WORKDIR /app/api
RUN dotnet publish -c release -o out


FROM microsoft/aspnetcore:2.0 AS runtime
WORKDIR /app
COPY api/model.zip .
COPY --from=build /app/api/out ./
ENTRYPOINT [&quot;dotnet&quot;, &quot;api.dll&quot;]
</code></pre>
<h3>Building Our Image</h3>
<p>To build the image, we need to enter the following command into the command prompt. This make take a while because it needs to download the .NET Core SDK and ASP.NET Core runtime Docker images.</p>
<pre><code class="language-bash">docker build -t &lt;DOCKERUSERNAME&gt;/&lt;IMAGENAME&gt;:latest .
</code></pre>
<h3>Test Image Locally</h3>
<p>We need to test our image locally to make sure it can run on the cloud. To do so, we can use the <code>docker run</code> command.</p>
<pre><code class="language-bash">docker run -d -p 5000:80 &lt;DOCKERUSERNAME&gt;/&lt;IMAGENAME&gt;:latest
</code></pre>
<p>Although the API is exposing port 80, we bind it to the local port 5000 just to keep our prior API request intact. When sending a POST request to <code>http://localhost:5000/api/predict</code> with the appropriate body, the response should again equal <code>Iris-virginica</code>.</p>
<p>To stop the container, use <code>Ctrl + C</code>.</p>
<h3>Push to Docker Hub</h3>
<p>Now that the Docker image is successfully running locally, it's time to push to Docker Hub. Again, we use the Docker CLI to do this.</p>
<pre><code class="language-bash">docker login
docker push &lt;DOCKERUSERNAME&gt;/&lt;IMAGENAME&gt;:latest
</code></pre>
<h2>Deploying To The Cloud</h2>
<p>Now comes the final step which is to deploy and expose our machine learning model and API to the world. Our deployment will occur via Azure Container Instances because it requires almost no provisioning or management of servers.</p>
<h3>Prepare Deployment Manifest</h3>
<p>Although deployments can be performed inline in the command line, it's usually best to place all the configurations in a file for documentation and to save time not having to type in the parameters every time. With Azure, we can do that via a JSON file.</p>
<pre><code class="language-json">{
  &quot;$schema&quot;:
    &quot;https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#&quot;,
  &quot;contentVersion&quot;: &quot;1.0.0.0&quot;,
  &quot;parameters&quot;: {
    &quot;containerGroupName&quot;: {
      &quot;type&quot;: &quot;string&quot;,
      &quot;defaultValue&quot;: &quot;mlnetacicontainergroup&quot;,
      &quot;metadata&quot;: {
        &quot;description&quot;: &quot;Container Group name.&quot;
      }
    }
  },
  &quot;variables&quot;: {
    &quot;containername&quot;: &quot;mlnetacidemo&quot;,
    &quot;containerimage&quot;: &quot;&lt;DOCKERUSERNAME&gt;/&lt;IMAGENAME&gt;:latest&quot;
  },
  &quot;resources&quot;: [
    {
      &quot;name&quot;: &quot;[parameters('containerGroupName')]&quot;,
      &quot;type&quot;: &quot;Microsoft.ContainerInstance/containerGroups&quot;,
      &quot;apiVersion&quot;: &quot;2018-04-01&quot;,
      &quot;location&quot;: &quot;[resourceGroup().location]&quot;,
      &quot;properties&quot;: {
        &quot;containers&quot;: [
          {
            &quot;name&quot;: &quot;[variables('containername')]&quot;,
            &quot;properties&quot;: {
              &quot;image&quot;: &quot;[variables('containerimage')]&quot;,
              &quot;resources&quot;: {
                &quot;requests&quot;: {
                  &quot;cpu&quot;: 1,
                  &quot;memoryInGb&quot;: 1.5
                }
              },
              &quot;ports&quot;: [
                {
                  &quot;port&quot;: 80
                }
              ]
            }
          }
        ],
        &quot;osType&quot;: &quot;Linux&quot;,
        &quot;ipAddress&quot;: {
          &quot;type&quot;: &quot;Public&quot;,
          &quot;ports&quot;: [
            {
              &quot;protocol&quot;: &quot;tcp&quot;,
              &quot;port&quot;: &quot;80&quot;
            }
          ]
        }
      }
    }
  ],
  &quot;outputs&quot;: {
    &quot;containerIPv4Address&quot;: {
      &quot;type&quot;: &quot;string&quot;,
      &quot;value&quot;:
        &quot;[reference(resourceId('Microsoft.ContainerInstance/containerGroups/', parameters('containerGroupName'))).ipAddress.ip]&quot;
    }
  }
}
</code></pre>
<p>It's a lot to look at but for now we can use this template and save it to the file <code>azuredeploy.json</code> in the root directory of our <code>mlnetacidemo</code> solution. The only thing that needs to be changed is the value of the <code>containerimage</code> property. Replace it with your Docker Hub username and the name of the image you just pushed to Docker Hub.</p>
<h3>Deploy</h3>
<p>In order to deploy our application we need to make sure to log into our Azure account. To do so via the Azure CLI, type into the command prompt:</p>
<pre><code class="language-bash">az login
</code></pre>
<p>Follow the prompts to log in. Once logged in, it's time to create a resource group for our container.</p>
<pre><code class="language-bash">az group create --name mlnetacidemogroup --location eastus
</code></pre>
<p>After the group has been successfully created it's time to deploy our application.</p>
<pre><code class="language-bash">az group deployment create --resource-group mlnetacidemogroup --template-file azuredeploy.json
</code></pre>
<p>Give it a few minutes for your deployment to initialize. If the deployment was successful, you should see some output on the command line. Look for the <code>ContainerIPv4Address</code> property. This is the IP Address where your container is accessible. In POSTMAN or Insomnia, replace the URL to which you previously made a POST request to with <code>http://&lt;ContainerIPv4Address&gt;/api/predict</code> where <code>ContainerIPv4Address</code> is the value that was returned to the command line after the deployment. If successful, the response should be just like previous requests <code>Iris-virginica</code>.</p>
<p>Once you're finished, you can clean up resources with the following command:</p>
<pre><code class="language-bash">az group delete --name mlnetacidemogroup
</code></pre>
<h2>Conclusion</h2>
<p>In this writeup, we built a classification machine learning model using <code>ML.NET</code> that predicts the class of an iris plant given four measurement features, exposed it via an ASP.NET Core REST API, packaged it into a container and deployed it to the cloud using Azure Container Instances. As the model changes and becomes more complex, the process is standardized enough that extending this example would require minimal changes to our existing application. Happy Coding!</p>
</div></main><script src="/js/jquery.slim.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/highlight.min.js"></script><script src="/js/highlight.fsharp.min.js"></script><script type="application/javascript">hljs.initHighlightingOnLoad();</script></body><footer><a rel="me" href="https://toot.lqdev.tech/@lqdev"></a></footer></html>