<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link rel="stylesheet" href="/assets/css/custom/main.css"><link rel="stylesheet" href="/assets/css/custom/timeline.css"><link rel="stylesheet" href="/assets/css/bootstrap-icons-1.5.0/bootstrap-icons.css"><link rel="stylesheet" href="/assets/css/highlight.github-dark-dimmed.min.css"><link rel="stylesheet" href="/assets/css/main.css"><link rel="stylesheet" href="/lib/revealjs/dist/reveal.css"><link rel="stylesheet" href="/lib/revealjs/dist/theme/black.css"><link rel="stylesheet" href="/lib/revealjs/plugin/highlight/monokai.css"><meta property="og:title" content="Accept Webmentions using F#, Azure Functions, and RSS - Luis Quintanilla"><meta property="og:type" content="website"><meta property="og:image" content="https://www.lqdev.me/avatar.png"><meta property="og:image:secure_url" content="https://www.lqdev.me/avatar.png"><meta property="og:image:type" content="image/png"><meta property="og:image:width" content="200"><meta property="og:image:height" content="200"><meta property="og:site_name" content="Luis Quintanilla Personal Website"><meta property="og:locale" content="en_US"><meta property="twitter:image" content="https://www.lqdev.me/avatar.png"><meta property="fediverse:creator" content="@lqdev@toot.lqdev.tech"><link rel="alternate" type="application/rss+xml" title="Luis Quintanilla Blog RSS Feed" href="/blog.rss"><link rel="alternate" type="application/rss+xml" title="Luis Quintanilla Microblog RSS Feed" href="/microblog.rss"><link rel="alternate" type="application/rss+xml" title="Luis Quintanilla Response RSS Feed" href="/responses.rss"><link rel="webmention" title="Luis Quintanilla Webmention Endpoint" href="https://webmentions.lqdev.tech/api/inbox"><link rel="feeds" type="text/xml" title="Luis Quintanilla&#39;s Feeds" href="/feed/index.opml"><link rel="blogroll" type="text/xml" title="Luis Quintanilla&#39;s Blogroll" href="/collections/blogroll/index.opml"><link rel="podroll" type="text/xml" title="Luis Quintanilla&#39;s Podroll" href="/collections/podroll/index.opml"><link rel="youtuberoll" type="text/xml" title="Luis Quintanilla&#39;s YouTube Roll" href="/collections/youtube/index.opml"><meta name="robots" content="nosnippet"><title>Accept Webmentions using F#, Azure Functions, and RSS - Luis Quintanilla</title></head><body><button class="mobile-toggle" id="mobile-nav-toggle" aria-label="Toggle navigation menu" aria-expanded="false"><div class="hamburger"><span></span><span></span><span></span></div></button><div class="nav-overlay" id="nav-overlay"></div><nav class="desert-nav" id="sidebar-menu" role="navigation" aria-label="Main navigation"><div class="nav-brand"><a href="/" class="brand-text"><img src="/avatar.png" alt="Luis Quintanilla avatar" loading="lazy">Luis Quintanilla</a></div><div class="nav-section"><a class="nav-link" href="/"><svg class="nav-icon" viewBox="0 0 16 16" fill="currentColor"><path d="M8.354 1.146a.5.5 0 0 0-.708 0l-6 6A.5.5 0 0 0 1.5 7.5v7a.5.5 0 0 0 .5.5h4.5a.5.5 0 0 0 .5-.5v-4h2v4a.5.5 0 0 0 .5.5H14a.5.5 0 0 0 .5-.5v-7a.5.5 0 0 0-.146-.354L8.354 1.146zM2.5 14V7.707l5.5-5.5 5.5 5.5V14H10v-4a.5.5 0 0 0-.5-.5h-3a.5.5 0 0 0-.5.5v4H2.5z"></path></svg>Home</a><a class="nav-link" href="/about"><svg class="nav-icon" viewBox="0 0 16 16" fill="currentColor"><path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"></path><path d="m8.93 6.588-2.29.287-.082.38.45.083c.294.07.352.176.288.469l-.738 3.468c-.194.897.105 1.319.808 1.319.545 0 1.178-.252 1.465-.598l.088-.416c-.2.176-.492.246-.686.246-.275 0-.375-.193-.304-.533L8.93 6.588zM9 4.5a1 1 0 1 1-2 0 1 1 0 0 1 2 0z"></path></svg>About</a><a class="nav-link" href="/contact"><svg class="nav-icon" viewBox="0 0 16 16" fill="currentColor"><path d="M0 4a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V4Zm2-1a1 1 0 0 0-1 1v.217l7 4.2 7-4.2V4a1 1 0 0 0-1-1H2Zm13 2.383-4.708 2.825L15 11.105V5.383Zm-.034 6.876-5.64-3.471L8 9.583l-1.326-.795-5.64 3.47A1 1 0 0 0 2 13h12a1 1 0 0 0 .966-.741ZM1 11.105l4.708-2.897L1 5.383v5.722Z"></path></svg>Contact</a><a class="nav-link" href="/search"><svg class="nav-icon" viewBox="0 0 16 16" fill="currentColor"><path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0z"></path></svg>Search</a><a class="nav-link" href="/feed"><svg class="nav-icon" viewBox="0 0 16 16" fill="currentColor"><path d="M5.5 12a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0zm-3-8.5a1 1 0 0 1 1-1c5.523 0 10 4.477 10 10a1 1 0 1 1-2 0 8 8 0 0 0-8-8 1 1 0 0 1-1-1zm0 4a1 1 0 0 1 1-1 6 6 0 0 1 6 6 1 1 0 1 1-2 0 4 4 0 0 0-4-4 1 1 0 0 1-1-1z"></path></svg>Subscribe</a></div><div class="nav-section dropdown"><button class="nav-link dropdown-toggle" data-target="collections-dropdown"><svg class="nav-icon" viewBox="0 0 16 16" fill="currentColor"><path d="M2.5 3A1.5 1.5 0 0 0 1 4.5v.793c.026.009.051.02.076.032L7.674 8.51c.206.1.446.1.652 0l6.598-3.185A.755.755 0 0 1 15 5.293V4.5A1.5 1.5 0 0 0 13.5 3h-11Z"></path><path d="M15 6.954 8.978 9.86a2.25 2.25 0 0 1-1.956 0L1 6.954V11.5A1.5 1.5 0 0 0 2.5 13h11a1.5 1.5 0 0 0 1.5-1.5V6.954Z"></path></svg>Collections<svg class="dropdown-arrow" viewBox="0 0 16 16" fill="currentColor"><path d="M7.247 11.14 2.451 5.658C1.885 5.013 2.345 4 3.204 4h9.592a1 1 0 0 1 .753 1.659l-4.796 5.48a1 1 0 0 1-1.506 0z"></path></svg></button><div class="dropdown-menu" id="collections-dropdown"><a class="dropdown-item" href="/collections/blogroll">Blogroll</a><a class="dropdown-item" href="/collections/podroll">Podroll</a><a class="dropdown-item" href="/collections/youtube">YouTube</a><a class="dropdown-item" href="/collections/forums">Forums</a><div class="dropdown-divider"></div><a class="dropdown-item" href="/collections/starter-packs">Starter Packs</a><div class="dropdown-divider"></div><a class="dropdown-item" href="/radio">Radio</a><a class="dropdown-item" href="/tags">Tags</a></div></div><div class="nav-section dropdown"><button class="nav-link dropdown-toggle" data-target="resources-dropdown"><svg class="nav-icon" viewBox="0 0 16 16" fill="currentColor"><path d="M1 2.828c.885-.37 2.154-.769 3.388-.893 1.33-.134 2.458.063 3.112.752v9.746c-.935-.53-2.12-.603-3.213-.493-1.18.12-2.37.461-3.287.811V2.828zm7.5-.141c.654-.689 1.782-.886 3.112-.752 1.234.124 2.503.523 3.388.893v9.923c-.918-.35-2.107-.692-3.287-.81-1.094-.111-2.278-.039-3.213.492V2.687zM8 1.783C7.015.936 5.587.81 4.287.94c-1.514.153-3.042.672-3.994 1.105A.5.5 0 0 0 0 2.5v11a.5.5 0 0 0 .707.455c.882-.4 2.303-.881 3.68-1.02 1.409-.142 2.59.087 3.223.877a.5.5 0 0 0 .78 0c.633-.79 1.814-1.019 3.222-.877 1.378.139 2.8.62 3.681 1.02A.5.5 0 0 0 16 13.5v-11a.5.5 0 0 0-.293-.455c-.952-.433-2.48-.952-3.994-1.105C10.413.809 8.985.936 8 1.783z"></path></svg>Resources<svg class="dropdown-arrow" viewBox="0 0 16 16" fill="currentColor"><path d="M7.247 11.14 2.451 5.658C1.885 5.013 2.345 4 3.204 4h9.592a1 1 0 0 1 .753 1.659l-4.796 5.48a1 1 0 0 1-1.506 0z"></path></svg></button><div class="dropdown-menu" id="resources-dropdown"><a class="dropdown-item" href="/resources/snippets">Snippets</a><a class="dropdown-item" href="/resources/wiki">Wiki</a><a class="dropdown-item" href="/resources/presentations">Presentations</a></div></div><div class="theme-toggle"><button class="theme-toggle-btn" id="theme-toggle" aria-label="Toggle dark mode"><span id="theme-toggle-icon">☀️</span><span>Theme</span></button></div></nav><main role="main" class="main-content" id="main-content"><div class="content-wrapper"><div class="mr-auto"><article class="h-entry individual-post"><header class="post-header"><h1 class="p-name post-title">Accept Webmentions using F#, Azure Functions, and RSS</h1><div class="post-meta"><time class="dt-published" datetime="2022-12-21 00:33 -05:00">December 21, 2022</time></div><div class="u-author h-card microformat-hidden"><img src="/avatar.png" class="u-photo" alt="Luis Quintanilla" /><a href="/about" class="u-url p-name">Luis Quintanilla</a></div></header><div class="e-content post-content"><h1>Introduction</h1>
<blockquote class="blockquote">
<p>This post is part of <a href="https://sergeytihon.com/2022/10/28/f-advent-calendar-in-english-2022/">F# Advent 2022</a>. Thanks to <a href="https://sergeytihon.com">Sergey Tihon</a> for organizing it.</p>
</blockquote>
<p>While not planned this way, this post is timely considering recent developments in the social media space. While Twitter is in the headlines, it's not the only time people have questioned their engagement and relationship with these social media platforms. In the context of Twitter though, users have been looking for alternative platforms to best serve their communities. While Mastodon and the Fediverse appear to be one of those alternatives, they're not the only one. Blogosphere platforms like Tumblr and WordPress, both owned by Automattic, are also positioning themselves as viable alternatives to the point they've <a href="https://techcrunch.com/2022/11/21/tumblr-to-add-support-for-activitypub-the-social-protocol-powering-mastodon-and-other-apps/">considered the idea of supporting ActivityPub</a>. ActivityPub is the protocol that powers many of the platforms on the Fediverse. However, it's not the only open protocol that enables communication and engagement on the open web. Webmentions is another protocol for enabling conversations on the web which I'll talk about more in this post.</p>
<p>I'll also discuss how I used F#, Azure Functions, and RSS to implement a solution that helps me and my website engage in conversations on the open web thanks to Webmentions.</p>
<h2>What are Webmentions?</h2>
<p>First, let's start by talking a bit about Webmentions.</p>
<p>According to the W3C specification, Webmentions are &quot;...a simple way to notify any URL when you mention it on your site. From the receiver's perspective, it's a way to request notifications when other sites mention it.&quot;.</p>
<p>One of the goals according to the IndieWeb wiki is to enable cross-site conversations.</p>
<p>Here's how a potential Webmention workflow might look like:</p>
<pre class="mermaid">sequenceDiagram
  autonumber
  actor A as Alice
  participant AS as Alice's "Website"
  participant AW as Alice's Webmention Service
  participant BS as Bob's "Website"
  actor B as Bob
  A ->> AS: Publishes post
  B ->> AS: Reads post
  B ->> BS: Publishes post with link to Alice's post
  rect rgb(230,230,230)
    alt Automated
      BS ->> AS: Fetch Webmention endpoint
      BS ->> AW: Sends Webmention
    else Manual
      B ->> AS: Fetch Webmention endpoint
      B ->> AW: Sends Webmention
    end 
  end
  rect rgb(230,230,230)
      note over AW:Validates Webmention request
      note over AW: Validates Webmention
      note over AW: Accepts / processes Webmention
      alt Automated
        AW ->> BS: Sends back response
      else Manual
        AW ->> B: Sends back response
      end
  end 
  opt Display Webmentions
    AS ->> AW: Fetch Webmentions
    note over AS: Display / publish Webmentions
  end
</pre>
<p>I use the term website here very loosely because it's not only limited to your own personal website. You can technically use Webmentions through any public website including social media platforms like Twitter, Mastodon, or even GitHub.</p>
<p>This post will focus on the middle blocks consisting of sending and receiving Webmentions. For more information, check out the <a href="https://www.w3.org/TR/webmention/#abstract-p-1">specification</a> and <a href="https://indieweb.org/Webmention">Webmentions page</a> on the IndieWeb wiki.</p>
<h2>My webmention solution</h2>
<p>In September of this year, I <a href="/notes/webmentions-partially-implemented/">integrated a partial implementation of Webmentions</a> into my website. This implementation only allowed me to send webmentions as part of my publishing process. If you're interested in the details, it's based on the blog post I wrote for last year's F# Advent, <a href="/posts/sending-webmentions-fsharp-fsadvent/">Sending Webmentions with F#</a>.</p>
<p>A couple of days ago, I <a href="/notes/now-accepting-webmentions">successfully deployed and integrated</a> the other part of the implementation which allowed me to receive webmentions. While there are many great <a href="https://indieweb.org/Webmention#Publisher_Services">services</a> which will do this for you, I decided to roll my own for fun and to learn something new.</p>
<p>To help with that, I released <a href="https://www.nuget.org/packages/lqdev.WebmentionFs">WebmentionFs</a>, an open-source .NET library written in F# with components for sending and receiving Webmentions.</p>
<p>The backend service I use to receive webmentions is built on Azure Functions.</p>
<p>If you're interested, here's the source code for <a href="https://github.com/lqdev/WebmentionFs">WebmentionFs</a> and my <a href="https://github.com/lqdev/WebmentionService">Webmention service</a>.</p>
<p>Before diving into the technical details of the solution, I'll first discuss some of the priorities driving my design decisions.</p>
<h3>Requirements</h3>
<p>While I don't want to trivialize it, at the end of the day, the Webmention service is just an endpoint that accepts HTTP POST requests. That means there's many ways to build it. However, here were the requirements important to me that guided my design choices:</p>
<ul>
<li><strong>Cost:</strong> The solution should be low cost</li>
<li><strong>Maintenance:</strong> The solution should be easy to maintain</li>
<li><strong>Easy to consume:</strong> I have multiple ways to view and access my webmentions.</li>
<li><strong>Notifications first:</strong> Since I don't own or have responsibility over content that's not mine, prioritize Webmentions for notifications, not content.</li>
</ul>
<p>With that in mind, I ended up choosing a solution built on Azure Functions to receive Webmentions and publish them as an RSS feed.</p>
<h3>Why Azure Functions?</h3>
<p>I don't make money from my website. It's a labor of love in which I document my experiences. Selfishly, it's for me to remind myself how to solve a problem or share something that was important to me at that time. If my posts end up helping others solve their own problems, that's a side effect and a reward unto itself. To that effect, I want my website to be as low-cost to run as possible. One way I achieve that is by using static hosting. This dramatically reduces the cost associated with my site. If you're interested in how this site is built, you can check out the <a href="/colophon">colophon</a>.</p>
<p>So where do Azure Functions come in?</p>
<p>Azure Functions is a serverless solution which means there are no servers! (I kid 😏)</p>
<h4>Cost ✔️</h4>
<p>As a serverless solutions, it means web services are not constantly running. They only run whenever there is something to process so I only pay for what I need. That takes care of my low-cost requirement since processing Webmentions is not a long-running, resource-intensive operation that can easily run in a serverless environment.</p>
<h4>Maintenance ✔️</h4>
<p>Cost is not only monetary. There are also time costs associated with maintaining a solution. Because there is no infrastructure to maintain, that's not really a factor I need to consider. Instead I get to focus on writing the logic for accepting and processing Webmentions. Azure Functions provides a set of <a href="https://learn.microsoft.com/azure/azure-functions/functions-triggers-bindings">prebuilt trigger and binding components</a> to reduce the amount of code I have to write to handle things like accepting HTTP requests or storing data in a table or blob storage. Also, in the rare instance that this blog post breaks the internet, Azure Functions enables my service to automatically handle that scale. Don't believe me? Check out this post frorm <a href="https://www.troyhunt.com/">Troy Hunt</a> on <a href="https://www.troyhunt.com/serverless-to-the-max-doing-big-things-for-small-dollars-with-cloudflare-workers-and-azure-functions/">Have I Been Pwned usage of Azure Functions</a>.</p>
<h3>Why RSS?</h3>
<p>The choice of how to display and consume Webmentions is entirely up to you. At regular intervals, my Webmention service generates an RSS feed and publishes it to a private Azure Blob Storage. Here are some of the reasons why:</p>
<h4>Easy to consume ✔️</h4>
<p>The decision to use RSS comes from the fact that like Webmentions, it's an open protocol that gives choice to creators and consumers. Check out my post, <a href="/posts/rediscovering-rss-user-freedom">Rediscovering the RSS protocol</a> for more of my thoughts on that. Despite the appearance of decline in use, it's a protocol that's been around for over 20 years and it's one of the many reasons why podcasts continue to be one of the more open platforms despite some attempts to lock down the ecosystem.  With that it mind, by choosing RSS as the publishing format for my Webmentions feed, I can lean on the vast number of RSS readers (<a href="http://newsblur.com/">NewsBlur</a> and <a href="https://github.com/skeeto/elfeed">Elfeed</a> being my favorites) out there instead of having to write a custom UI. Not happy with my RSS reader? I can just add my feed to whichever other reader I move to and continue consuming my Webmentions without skipping a beat.</p>
<h3>Notifications first ✔️</h3>
<p>While not technical or specific to RSS, this is a topic I wrestled with as part of my implementation. However, choosing RSS made many parts of it simpler.</p>
<p>Who owns your content? If you publish on your own website or a platform under your control, chances are you do. If I publish and redistribute your content on my website though, what parts do I own and which parts do you? I'm not sure. What about spam, harrassment, and lewd content? I'd have to put in place some sort of moderation instead of publishing directly on my site. I didn't want to have to deal with any of these questions so choosing to publish to a private RSS feed instead of directly on my site made it so Webmentions are for my eyes only. More importantly, I only capture the source and target links, not the content. Therefore, I don't store or redistribute your content. Now there's nothing stopping anyone from seeing your post since it's public but in cases where your site's content is not something I'm comfortable with, I'm not resharing or redistributing that content. If my RSS reader chooses to display the full contents of your post by using the <code>link</code> element from the RSS feed, since your post is public, that's no different than me viewing the original post on your site. If at some point I feel differently about it, the changes to capture the content in the <code>description</code> happen at the RSS file level and because the RSS is private, I'm still not redistributing your content.</p>
<p>In short, with my implementation I chose to prioritize Webmentions for notification purposes rather than building a commenting and interaction (like, reshare) system for my website.</p>
<p>Now that I've talked about the what and the why, in the next sections I'll get into the how.</p>
<h2>Sending Webmentions</h2>
<p>Once you've created a post linking to someone else's website, sending webmentions is a two-step process:</p>
<ol>
<li>URL discovery of webmention endpoint</li>
<li>Send webmention</li>
</ol>
<p>These steps can be automated or performed manually.</p>
<h3>URL discovery of Webmention endpoint</h3>
<p>The first thing you'll need is the endpoint where you'll be sending your Webmention to.</p>
<p>According to the Webmention specification, a Webmention endpoint can be found in one of three places:</p>
<ul>
<li>HTTP response headers</li>
<li><code>&lt;link&gt;</code> tag with <code>rel=webmention</code> attribute</li>
<li><code>&lt;a&gt;</code> tag with <code>rel=me</code> attribute</li>
</ul>
<p>When this process is automated, the discovery is performed in order and each subsequent option works as a fallback of the other. When done manually, either the website author will publish and advertise this on their website or you can inspect the website's source code to find it.</p>
<h3>Send webmention</h3>
<p>To send a Webmention, you need to send an HTTP POST request with an <code>x-www-form-urlencoded</code> body containing two properties: <code>source</code> and <code>target</code>. Source is the URL of your article and target is the URL of the original article. Again, this too can either be automated or done manually with tools like cURL, Insomnia, or any other HTTP client.</p>
<h3>Sending Webmentions in practice</h3>
<p>Let's use a redundant example to walk through the workflow. Pretend that you created or commented on a GitHub issue and added a link to one of my articles, <a href="/posts/sending-webmentions-fsharp-fsadvent/">Sending Webmentions with F#</a> for example. You then wanted to notify me either to get my attention on that issue or just as an FYI. Now I say this is a redundant example because GitHub already has notifications. However, what this does illustrate are the cross-site capabilities of Webmentions.</p>
<p><img src="http://cdn.lqdev.tech/files/images/send-gh-issue.png" class="img-fluid" alt="Image of GitHub Issue Post" /></p>
<p>At this point, if GitHub implemented Webmentions, it would automatically:</p>
<ol>
<li>Fetch my webpage and look for my Webmention endpoint.</li>
<li>Compose and send the HTTP POST request.</li>
</ol>
<p>Sadly, today that's not the case so we'll walk through the workflow manually.</p>
<p>On my website, I include a <code>link</code> tag with the <code>rel=webmention</code> attribute that looks like the following:</p>
<pre><code class="language-html">&lt;link rel=&quot;webmention&quot; title=&quot;Luis Quintanilla Webmention Endpoint&quot; href=&quot;https://lqdevwebmentions.azurewebsites.net/api/inbox&quot;&gt;
</code></pre>
<p>My current Webmention endpoint is <em>https://lqdevwebmentions.azurewebsites.net/api/inbox</em>.</p>
<p>Now that you have the Webmention endpoint, you could use any tool of your choice to create and send the HTTP POST request. I have made it simpler though and included a form on my website for each of my posts for this purpose.</p>
<p><img src="http://cdn.lqdev.tech/files/images/send-webmention-form.png" class="img-fluid" alt="luisquintanilla.me send Webmention form" /></p>
<p>The source code looks like the following:</p>
<pre><code class="language-html">&lt;div&gt;
    &lt;script type=&quot;application/javascript&quot;&gt;window.onload = function() { document.getElementById('webmention-target').value = window.location.href }&lt;/script&gt;
    &lt;form action=&quot;https://lqdevwebmentions.azurewebsites.net/api/inbox&quot; method=&quot;POST&quot; enctype=&quot;application/x-www-form-urlencoded&quot;&gt;
        &lt;h5 class=&quot;text-center&quot;&gt;Send me a &lt;a href=&quot;https://indieweb.org/webmentions&quot;&gt;webmention&lt;/a&gt;&lt;/h5&gt;
        &lt;div class=&quot;form-row justify-content-center&quot;&gt;
            &lt;div class=&quot;w-75&quot;&gt;
                &lt;input type=&quot;text&quot; name=&quot;source&quot; class=&quot;form-control&quot; placeholder=&quot;Your URL (source)&quot;&gt;
            &lt;/div&gt;
            &lt;div class=&quot;col-auto&quot;&gt;
                &lt;input type=&quot;submit&quot; class=&quot;btn btn-primary&quot; value=&quot;Send&quot;&gt;
            &lt;/div&gt;
            &lt;input readonly=&quot;&quot; class=&quot;form-control-plaintext&quot; style=&quot;visibility:hidden&quot; type=&quot;text&quot; id=&quot;webmention-target&quot; name=&quot;target&quot;&gt;
        &lt;/div&gt;
    &lt;/form&gt;
&lt;/div&gt;
</code></pre>
<p>Now to send the webmention, navigate to the post you want to send a Webmention to. In this case, it's <a href="/posts/sending-webmentions-fsharp-fsadvent/">Sending Webmentions with F#</a>. Then, paste the link to the GitHub issue that contains the link to my site into the post's text box and hit &quot;Send&quot;.</p>
<p><img src="http://cdn.lqdev.tech/files/images/send-webmention-form-populated.png" class="img-fluid" alt="luisquintanilla.me send Webmention form filled-in" /></p>
<p>At that point, the request is sent to my Webmention service which receives and processes the request and responds with a message whether the request was successful or not.</p>
<p>That's all there is to it! Before moving the the receiving process though, I'll briefly show how to send Webmentions using WebmentionFs.</p>
<h3>Sending Webmentions with WebmentionFs</h3>
<p>In WebmentionFs, you can use the <a href="https://github.com/lqdev/WebmentionFs/blob/main/UrlDiscoveryService.fs"><code>UrlDiscoveryService</code></a> and <a href="https://github.com/lqdev/WebmentionFs/blob/main/WebmentionSenderService.fs"><code>WebmentionSenderService</code></a> to send Webmentions. If you wanted to integrate sending Webmentions into your application or service, here's an example that shows how you'd use those components.</p>
<pre><code class="language-fsharp">open System
open WebmentionFs
open WebmentionFs.Services

let ds = new UrlDiscoveryService()

let ws = new WebmentionSenderService(ds)

let data = 
    {   
        Source = new Uri(&quot;https://twitter.com/ljquintanilla/status/1603602055435894784&quot;)  
        Target = new Uri(&quot;/feed/mastodon-hashtag-rss-boffosocko&quot;)
    }

ws.SendAsync(data) |&gt; Async.AwaitTask |&gt; Async.RunSynchronously
</code></pre>
<p>The main part to pay attention to is the <code>SendAsync</code> function. This uses the <code>UrlDiscoveryService</code> to perform the Webmention endpoint discovery and send the HTTP POST request with the provided data.</p>
<h2>Receiving webmentions</h2>
<p>Now that you know how to send webmentions, let's talk about what happens on the receiver end. At its core, it's about a three-step process:</p>
<ol>
<li>Validate request</li>
<li>Validate Webmention</li>
<li>Process Webmention</li>
</ol>
<h3>Validate request</h3>
<p>Before processing the Webmention, you want to make sure that the request is valid. To do so there are a few checks you perform:</p>
<ol>
<li>Is the protocol valid? Check that the protocol for the source and target URLs in the request body are HTTP or HTTPS.</li>
<li>Are the URLs the same? Check that the source and target URLS in the request body are NOT the same.</li>
<li>Is the target URL a valid resource? This is more loosely defined and up to you. In my case I defined valid as:
<ul>
<li>I own the domain</li>
<li>The target URL doesn't return an HTTP 400 or 500 error.</li>
</ul>
</li>
</ol>
<p>If the request is not valid, nothing is done with the Webmention and an error returns. Otherwise, it moves to the next step which is Webmention validation.</p>
<h3>Validate Webmention</h3>
<p>In the base case, Webmention validation just means you parse through the source document and make sure that the target URL is included in it. However, if you wanted to get more complex and take into account specific types of interactions such as likes, replies, reposts, bookmarks, etc. you can parse through the document looking for <a href="http://microformats.org/wiki/h-entry#Core_Properties">microformat</a> annotations. For more information on these annotations, see the <a href="https://indieweb.org/posts#Types_of_Posts">Types of Posts</a> or <a href="https://indieweb.org/reply#Post_a_reply">reply</a> pages in the IndieWeb Wiki.</p>
<p>If the target link is NOT in the source document, you return an error. Otherwise, you move to the next step of processing the Webmention</p>
<h3>Processing Webmentions</h3>
<p>This step is optional and loosely defined. Once you've validated the request and Webmention, you can do with it as you please. One thing you can do is publish it (after moderation) on your website.</p>
<p>In my case, I'm storing it in an Azure Tables database. Then, every morning, I generate an RSS feed of all my webmentions and save it to a private container on Azure Blob Storage.</p>
<h2>Reciving Webmentions with WebmentionFs</h2>
<p>To receive Webmentions, I use the <a href="https://github.com/lqdev/WebmentionFs/blob/main/RequestValidationService.fs"><code>RequestValidationService</code></a>, <a href="https://github.com/lqdev/WebmentionFs/blob/main/WebmentionValidationService.fs"><code>WebmentionValidationService</code></a> and <a href="https://github.com/lqdev/WebmentionFs/blob/main/WebmentionReceiverService.fs"><code>WebmentionReceiverService</code></a> inside my Azure Function.</p>
<p>The source code for my Azure Function is available in the <a href="https://github.com/lqdev/WebmentionService">WebmentionService GitHub repo</a>.</p>
<p>The main components are in the <code>Startup.fs</code> and <code>ReceiveWebmention.fs</code> files.</p>
<p>The <a href="https://github.com/lqdev/WebmentionService/blob/main/Startup.fs"><code>Startup.fs</code></a> files registers each of the services I'll use to to receive Webmentions. By doing so, I define the initialization logic for use later in my application using dependency injection. The main thing to note here is that the <code>WebmentionReceiverService</code> is initialized with instances of a <code>RequestValidationService</code> and <code>WebmentionValidationService</code>. For the <code>RequestValidationService</code>, it's initialized with a list of host names. In this case, I'm passing it in as a comma-delimited environment variable that looks something like &quot;lqdev.me,luisquintanilla.me&quot;. This is what the <code>RequestValidationService</code> uses to check whether I own a domain.</p>
<pre><code class="language-fsharp">// Add request validation service
builder.Services.AddScoped&lt;RequestValidationService&gt;(fun _ -&gt; 

    let hostNames = Environment.GetEnvironmentVariable(&quot;PERSONAL_WEBSITE_HOSTNAMES&quot;)

    let hostNameList = hostNames.Split(',')

    new RequestValidationService(hostNameList)) |&gt; ignore


// Add webmention validation service
builder.Services.AddScoped&lt;WebmentionValidationService&gt;() |&gt; ignore

// Add receiver service
builder.Services.AddScoped&lt;IWebmentionReceiver&lt;Webmention&gt;,WebmentionReceiverService&gt;(fun (s:IServiceProvider) -&gt;
    let requestValidationService = s.GetRequiredService&lt;RequestValidationService&gt;()
    let webmentionValidationService = s.GetRequiredService&lt;WebmentionValidationService&gt;()
    new WebmentionReceiverService(requestValidationService,webmentionValidationService)) |&gt; ignore
</code></pre>
<p>Then, in the <a href="https://github.com/lqdev/WebmentionService/blob/main/ReceiveWebmention.fs"><code>ReceiveWebmention.fs</code></a> file, I inject my <code>WebmentionReceiverService</code> into the constructor and add all the logic for running my serverless function in the <code>Run</code> function. In this snippet, some code is ommitted for brevity.</p>
<pre><code class="language-fsharp">type ReceiveWebmention (webmentionReceiver: IWebmentionReceiver&lt;Webmention&gt;) = 

    ///...

    [&lt;FunctionName(&quot;ReceiveWebmention&quot;)&gt;]
    member x.Run 
        ([&lt;HttpTrigger(AuthorizationLevel.Anonymous, &quot;post&quot;, Route = &quot;inbox&quot;)&gt;] req: HttpRequest) 
        ([&lt;Table(&quot;webmentions&quot;, Connection=&quot;AzureWebJobsStorage&quot;)&gt;] t: TableClient)
        (log: ILogger) =
        task {
            
            log.LogInformation(&quot;Processing webmention request&quot;)

            let! validationResult = x.WebmentionReceiver.ReceiveAsync(req)

            let response = 
                match validationResult with
                | ValidationSuccess m -&gt; 
                    let entity = mapMentionToTableEntity m
                    try
                        t.AddEntity(entity) |&gt; ignore
                        OkObjectResult(&quot;Webmention processed successfully&quot;) :&gt; IActionResult
                    with
                        | ex -&gt; 
                            log.LogError($&quot;{ex}&quot;)
                            BadRequestObjectResult($&quot;Error processing webmention. Webmention already exists&quot;) :&gt; IActionResult
                | ValidationError e -&gt; 
                    log.LogError(e)
                    BadRequestObjectResult(e) :&gt; IActionResult

            return response

        }
</code></pre>
<p>The <code>Run</code> function is triggered whenever an HTTP POST request is made to my Webmention endpoint. It then calls <code>ReceiveAsync</code> on the <code>WebmentionReceiverService</code> which under the hood uses the <code>RequestValidationService</code> and <code>WebmentionValidationService</code> for validation. For reference, here's the code that does that in WebmentionFS.</p>
<pre><code class="language-fsharp">member x.ReceiveAsync (data:UrlData) = 
    task {
        let! requestValidationResult = 
            x.RequestValidationService.ValidateAsync data

        match requestValidationResult with
        | RequestSuccess r -&gt; 
            let! webmentionValidationResult = 
                x.WembentionValidationService.ValidateAsync r.Source r.Target

            let (result:ValidationResult&lt;Webmention&gt;) = 
                match webmentionValidationResult with
                | AnnotatedMention m -&gt; 
                    ValidationSuccess {RequestBody = r; Mentions = m}
                | UnannotatedMention -&gt; 
                    ValidationSuccess 
                        {
                            RequestBody = r
                            Mentions = 
                                {
                                    IsBookmark = false
                                    IsLike = false
                                    IsReply = false
                                    IsRepost = false        
                                }
                        }
                | MentionError e -&gt; ValidationError e
            return result
        | RequestError e -&gt; return ValidationError e
    }
</code></pre>
<blockquote class="blockquote">
<p>A quick side-note. I love how elegant function composition in F# makes the request validation pipeline look. See for yourself 🙂</p>
<pre><code class="language-fsharp">let validateAsync = 
   isProtocolValid &gt;&gt; isSameUrl &gt;&gt; isTargetUrlValidAsync
</code></pre>
</blockquote>
<p>Inside my <code>Run</code> function, if the request and Webmention validation are successful, I use the Azure Table Storage table client <code>AddEntity</code> method to save the Webmention to a table. One thing to note is that <code>AddEntity</code> ensures that an entry is only added once. If an entry already exists in the table, it returns an error.</p>
<p>This is what the GitHub Webmention we sent looks like in the table.</p>
<p><img src="http://cdn.lqdev.tech/files/images/webmentions-azure-table.png" class="img-fluid" alt="Webmentions table on Azure Table Storage" /></p>
<p>In this case, the <code>PartitionKey</code> is the target URL and <code>RowKey</code> is the source URL. The fact all other columns are set to false indicates this is an untagged mention with no special microformats annotations. Annotating your posts appropriately would set one or more of those columns to true.</p>
<p>Now that we went over how I receive Webmentions, I'll show how I prepare my Webmentions for consumption.</p>
<h2>Viewing Webmentions</h2>
<p>I consume my Webmentions using RSS feeds and RSS readers. To do so, I have an Azure Function called <a href="https://github.com/lqdev/WebmentionService/blob/main/WebmentionToRss.fs"><code>WebmentionToRss</code></a> that triggers every day at 3 AM. This function queries the Azure Table Storage table containing my Webmentions and creates an RSS feed that's then stored to Azure Blob Storage. Like the other function to process my Webmentions, I:</p>
<p>Register the <code>RssService</code> responsible for generating the RSS feed in <code>Startup.fs</code>.</p>
<pre><code class="language-fsharp">// Add RSS service
builder.Services.AddScoped&lt;RssService&gt;() |&gt; ignore
</code></pre>
<p>Inject the service into my <code>WebmentionToRss</code> constructor. Then in my <code>Run</code> function, I call the <code>getMentions</code> helper function to query the table, call <code>BuildRssFeed</code> to generate the feed, and write it out to Azure Blob Storage using a <code>Stream</code>.</p>
<pre><code class="language-fsharp">type WebmentionToRss (rssService:RssService) =

    let getMentions (t:TableClient) = 

        //...

        let webmentions = t.Query&lt;WebmentionEntity&gt;()

        webmentions


    //...

    [&lt;FunctionName(&quot;WebmentionToRss&quot;)&gt;]
    member x.Run
        ([&lt;TimerTrigger(&quot;0 0 3 * * *&quot;)&gt;] info: TimerInfo)
        ([&lt;Table(&quot;webmentions&quot;,Connection=&quot;AzureWebJobsStorage&quot;)&gt;] t: TableClient)
        ([&lt;Blob(&quot;feeds/webmentions/index.xml&quot;, FileAccess.Write, Connection=&quot;AzureWebJobsStorage&quot;)&gt;] rssBlob: Stream)
        (log: ILogger) =

        task {
            let mentions = getMentions t

            let rss = x.RssService.BuildRssFeed mentions &quot;lqdev's Webmentions&quot; &quot;http://lqdev.me&quot; &quot;lqdev's Webmentions&quot; &quot;en&quot;

            log.LogInformation(rss.ToString())                

            use xmlWriter = XmlWriter.Create(rssBlob)

            rss.WriteTo(xmlWriter) |&gt; ignore
        }
</code></pre>
<p>Now, to view my feed I add the URL to the RSS file in Azure Blob Storage to my RSS feed reader. The container and blob containing the file are private though, so how does my RSS reader get access to the file? I don't use the direct link. Instead, I use a link containing a <a href="https://learn.microsoft.com/azure/storage/common/storage-sas-overview#sas-token">Shared Access Signatures (SAS) token</a>.</p>
<p>The RSS feed reader then fetches my Webmentions feed at regular intervals.</p>
<p>This is what the GitHub post looks like in my RSS reader.</p>
<p><img src="http://cdn.lqdev.tech/files/images/newsblur-webmentions-rss-feed.png" class="img-fluid" alt="Webmentions table on Azure Table Storage" /></p>
<p>That's all there is to it!</p>
<h2>What's next?</h2>
<p>Overall I'm happy with my solution. I learned a few things along the way and got something working for myself. Publishing WebmentionFs as a library and making my Azure Function code open-source were attempts to help others looking to implement similar solutions get started. These solitions could be improved though. These are some updates I would like to make at some point:</p>
<ul>
<li>Upgrade my website to use WebmentionFs for sending Webmentions. You can see the <a href="https://github.com/lqdev/luisquintanilla.me/blob/main/Services/Webmention.fs">current implementation</a> on my website repo which is basically what's in <code>UrlDiscoveryService</code> and <code>WebmentionSenderService</code> today.</li>
<li>Add interfaces for all services in WebmentionFs. Currently most services have concrete implementations. By adding interfaces, I can make the library extensible and you can implement your own URL discovery and validation services.</li>
<li>Implement <code>outbox</code> enpoint in WebmentionService to handle sending Webmentions.</li>
<li>Create Azure ARM template for deploying WebmentionService. Currently with some small edits, you could fork and get my WebmentionService project working for your website. However, that process isn't turnkey today. Maybe using something like <a href="https://compositionalit.github.io/farmer/">Farmer</a> would make onboarding easier for folks.</li>
</ul>
<h2>Conclusion</h2>
<p>Webmentions are a great way to enable cross-site conversations on the internet. In this post, I provided a brief introduction to the general workflow for sending and receiving Webmentions. I also detailed my own implementation which I use today on my website. That implementation relies on the WebmentionFs .NET library, Azure Functions, and RSS. By using the WebmentionFs .NET library, you can more quickly implement similar solutions into your own apps and services. If you need a reference, check out my WebmentionService repository on GitHub which contains the code I use for receiving Webmentions.</p>
<p>I'll leave you with three things:</p>
<ol>
<li>As you consider the next platform for your next online home, in addition to considering the health of the community, take some time to also think about the protocols it's built on top of and whether they give you more or less freedom.</li>
<li>Try out the WebmentionFs library on NuGet and add Webmentions to your site.</li>
<li>If you share this post anywhere publicly on the web, send me a Webmention.</li>
</ol>
<p>Catch you on the world wide web!</p>
</div><footer class="post-footer"><div class="permalink-info">Permalink: <a class="u-url permalink-link" href="/posts/receive-webmentions-fsharp-az-functions-fsadvent/">/posts/receive-webmentions-fsharp-az-functions-fsadvent/</a></div><div><script type="application/javascript">window.onload = function() { document.getElementById('webmention-target').value = window.location.href }</script><form action="https://webmentions.lqdev.tech/api/inbox" method="POST" enctype="application/x-www-form-urlencoded"><h5 class="text-center">Send me a <a href="/contact">message</a> or <a href="https://indieweb.org/webmentions">webmention</a></h5><div class="form-row justify-content-center"><div class="w-75"><input type="url" class="form-control" name="source" placeholder="Your URL (webmention source)" required /></div><div class="col-auto"><input type="submit" class="btn btn-primary" value="Send" /></div><input type="hidden" readonly name="target" id="webmention-target" /></div></form></div></footer></article></div></div></main><script src="/assets/lib/jquery/jquery.slim.min.js"></script><script src="/assets/lib/boostrap/bootstrap.min.js"></script><script src="/assets/lib/highlight/highlight.min.js"></script><script src="/assets/lib/highlight/highlight.fsharp.min.js"></script><script src="/assets/lib/highlight/highlight.nix.min.js"></script><script src="/assets/js/timeline.js"></script><script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script><script type="application/javascript">mermaid.initialize({startOnLoad:true});</script><script type="application/javascript">hljs.initHighlightingOnLoad();</script><script src="/lib/revealjs/dist/reveal.js"></script><script src="/lib/revealjs/plugin/markdown/markdown.js"></script><script src="/lib/revealjs/plugin/highlight/highlight.js"></script><script type="application/javascript">
                    // Initialize Reveal.js when a presentation container is found on the page
                    document.addEventListener('DOMContentLoaded', function() {
                        const presentationContainer = document.querySelector('.presentation-container');
                        if (presentationContainer && typeof Reveal !== 'undefined') {
                            Reveal.initialize({
                                plugins: [RevealMarkdown, RevealHighlight],
                                embedded: true
                            });
                        }
                    });
                    </script></body><footer><a rel="me" href="https://toot.lqdev.tech/@lqdev"></a><a rel="me" href="https://github.com/lqdev"></a><a rel="me" href="https://twitter.com/ljquintanilla"></a><a rel="me" href="https://www.linkedin.com/in/lquintanilla01/"></a><a rel="me" href="mailto:lqdev@outlook.com"></a></footer></html>