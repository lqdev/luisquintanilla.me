<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>Luis Quintanilla - social</title>
    <link>https://www.lqdev.me/tags/social</link>
    <description>All content tagged with 'social' by Luis Quintanilla</description>
    <lastBuildDate>2025-05-26 18:14 -05:00</lastBuildDate>
    <language>en</language>
    <item>
      <title>The stage has been set for the growth of small social media</title>
      <description>&lt;![CDATA[[reshare] &lt;blockquote class="blockquote"&gt;
&lt;p&gt;Last month during Meta's antitrust trial, Mark Zuckerberg admitted that his company's focus has changed radically from where it began...[his] testimony implies that Facebook (Meta) may no longer be as much of an option if we actually want to talk to each other on line. But, neither are many of the other large social media sites.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;...if companies allowed us to discover great new small blogs and small social media sites, many of us would decide to spend more time there. Then, companies would be less able to advertise to us on their own sites.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;...we have been told by the mainstream media for well over a decade that small social media is dead. They say the same about small blogs, yet small blogs are actually more plentiful than ever, with over &lt;a href="https://firstsiteguide.com/blogging-stat"&gt;600 million blogs&lt;/a&gt; on the Internet and about 7 million new blog articles published each day.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;If you decide to create your own forum, do yourself a favor. The way to protect yourself and your users is by &lt;strong&gt;running your social media site at a domain that you own and on a server that you control&lt;/strong&gt;, and don't agree to hand over any of your rights to anyone for any reason.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;I believe large corporate-run social media sites are vulnerable in a way they have not been for twenty years. Their users have reached a state of extreme dissatisfaction with their &amp;quot;enshittified&amp;quot; platforms, and they are looking for something, anything, better.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;But each of you who are reading these words can help end this situation by creating your own small social media site.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;All you need to start your own small site is a domain name, a server that you can buy, rent, or set up on an old computer, perhaps social media software (see above), patience, a willingness to work, and ideas for ways of notifying potential users of the existence of your site.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;Run your new site as you and your users see fit, and make it far superior to Facebook, Twitter (X), Reddit, or any of the other major sites whose owners think you have no other options.&lt;/p&gt;
&lt;/blockquote&gt;
]]&gt;</description>
      <link>https://www.lqdev.me/responses/stage-set-growth-small-social-media-cheapskate</link>
      <guid>https://www.lqdev.me/responses/stage-set-growth-small-social-media-cheapskate</guid>
      <pubDate>2025-05-26 18:14 -05:00</pubDate>
      <category>social</category>
      <category>openweb</category>
      <category>personalweb</category>
    </item>
    <item>
      <title>Announcing Distributed.Press Social Inbox 1.0</title>
      <description>&lt;![CDATA[[reshare] &lt;p&gt;I hadn't heard of &lt;a href="https://distributed.press/"&gt;Distributed Press&lt;/a&gt; and this is an older post (from 2023), but the idea is interesting.&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;Hypha and Sutty are thrilled to announce the release of the Social Inbox, a new feature of Distributed.Press that integrates a website’s comment section with federated social media platforms like Mastodon. With the Social Inbox enabled, websites obtain their own account on the Fediverse, allowing it to automatically send out new posts to followers at the time of publication. When other users reply to posts, you can approve them to be published to the site as comments. The Social Inbox allows readers to directly engage with your posts where they already are, and gives publishers the ability to incorporate public dialogue into their websites.&lt;/p&gt;
&lt;/blockquote&gt;
]]&gt;</description>
      <link>https://www.lqdev.me/responses/announcing-distributed-press-social-inbox</link>
      <guid>https://www.lqdev.me/responses/announcing-distributed-press-social-inbox</guid>
      <pubDate>2025-05-10 20:47 -05:00</pubDate>
      <category>decentralization</category>
      <category>indieweb</category>
      <category>social</category>
      <category>fediverse</category>
      <category>dweb</category>
    </item>
    <item>
      <title>Discourse and the Fediverse</title>
      <description>&lt;![CDATA[[star] &lt;blockquote class="blockquote"&gt;
&lt;p&gt;Two years ago, we started working on a plugin that brings Discourse and the Fediverse closer together. Discourse communities are online spaces that facilitate open collaboration and communication. The Fediverse offers ways to expand the reach of Discourse communities and help them build bridges with people active in other spaces, all while keeping the conversation civil, meaningful and focused. This post will describe how the ActivityPub plugin works and how you can enable your Discourse community to connect with other communities or Fediverse users.&lt;/p&gt;
&lt;/blockquote&gt;
]]&gt;</description>
      <link>https://www.lqdev.me/responses/discourse-fediverse</link>
      <guid>https://www.lqdev.me/responses/discourse-fediverse</guid>
      <pubDate>2025-05-09 22:20 -05:00</pubDate>
      <category>discourse</category>
      <category>fediverse</category>
      <category>social</category>
      <category>openweb</category>
      <category>opensource</category>
      <category>forum</category>
    </item>
    <item>
      <title>socialweb.network</title>
      <description>&lt;![CDATA[[reshare] &lt;blockquote class="blockquote"&gt;
&lt;p&gt;Your gateway to decentralized social networking protocols, resources, and community&lt;/p&gt;
&lt;/blockquote&gt;
]]&gt;</description>
      <link>https://www.lqdev.me/responses/socialweb-network</link>
      <guid>https://www.lqdev.me/responses/socialweb-network</guid>
      <pubDate>2025-05-09 20:49 -05:00</pubDate>
      <category>fediverse</category>
      <category>social</category>
      <category>openweb</category>
      <category>decentralized</category>
      <category>community</category>
      <category>indieweb</category>
    </item>
    <item>
      <title>How I turned my blog into a social media hub</title>
      <description>&lt;![CDATA[[reshare] &lt;blockquote class="blockquote"&gt;
&lt;p&gt;...my blog has become a central hub for almost everything I write online, including nearly all my social media posts, links to my published work on other sites, and the occasional freestanding blog post. While this approach has a few trade-offs, I feel better about posting in the first place knowing that I’m doing it on my own terms.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;There’s also just something deeply satisfying about seeing a running feed of my own writing, on my own website, with my own design and presentation. A social network alone can’t replicate that, but the POSSE approach offers the best of both worlds.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I've enjoyed seeing over the past few weeks, as people seek new online platforms, the personal website is being rediscovered.&lt;/p&gt;
]]&gt;</description>
      <link>https://www.lqdev.me/responses/how-i-turned-website-social-media-hub-newman</link>
      <guid>https://www.lqdev.me/responses/how-i-turned-website-social-media-hub-newman</guid>
      <pubDate>2024-12-05 19:22 -05:00</pubDate>
      <category>indieweb</category>
      <category>social</category>
      <category>microblog</category>
      <category>blogging</category>
      <category>internet</category>
      <category>web</category>
      <category>socialmedia</category>
    </item>
    <item>
      <title>Mastodon instance working again</title>
      <description>&lt;![CDATA[&lt;p&gt;After about a month of not being able to access my Mastodon instance, I'm so excited to have it working again!&lt;/p&gt;
&lt;p&gt;Not sure what I did wrong with my upgrade to 4.3.0. Fortunately, the issues appears to have been on the frontend and the fix wasn't too involved.&lt;/p&gt;
&lt;p&gt;Upgrading to the latest 4.3.1 fixed the issue I ran into during my last upgrade.&lt;/p&gt;
&lt;p&gt;Thanks to my &lt;a href="https://www.lqdev.me/posts/rss-to-mastodon-posse-azure-logic-apps/"&gt;POSSE setup&lt;/a&gt;, I've been able to continue posting to my website and syndicating to Mastodon. Unfortunately, since the frontend wasn't working, I was unable to access my notifications. Because the mobile apps make use of the web frontend to log in, I couldn't use the mobile app either.&lt;/p&gt;
]]&gt;</description>
      <link>https://www.lqdev.me/notes/mastodon-working-again-v-4-3-1</link>
      <guid>https://www.lqdev.me/notes/mastodon-working-again-v-4-3-1</guid>
      <pubDate>2024-11-18 17:34 -05:00</pubDate>
      <category>mastodon</category>
      <category>fediverse</category>
      <category>sysadmin</category>
      <category>selfhost</category>
      <category>socialmedia</category>
      <category>social</category>
      <category>microblog</category>
      <category>indieweb</category>
      <category>posse</category>
    </item>
    <item>
      <title>Deep Questions - Debunking AI Model Capabilities / Distributed Webs of Trust</title>
      <description>&lt;![CDATA[[reply] &lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=OvlfCW3Ec1g" title="Deep Questions Podcast Debunking AI Episode Thumbnail"&gt;&lt;img src="http://img.youtube.com/vi/OvlfCW3Ec1g/0.jpg" class="img-fluid" alt="Deep Questions Podcast Debunking AI Episode Thumbnail" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Nice job by Cal debunking misconceptions about AI model capabilities. The segment highlights a few points I cover in my unpublished &lt;a href="https://github.com/lqdev/luisquintanilla.me/blob/main/_scratch/nolm-not-only-language-models.md"&gt;NoLM - Not Only Language Models&lt;/a&gt; blog post. Specifically the fact that Language Models on their own can't do much and need to be connected to data sources and other systems. Complex AI systems will be built with more specialized roles and leverage various components for their planning and execution. In the end though, models will require integration into existing systems. Those integrations need to be done by people, meaning humans are still in control of the AI-assisted system capabilities.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=OvlfCW3Ec1g&amp;amp;t=4082" title="Deep Questions Podcast Debunking AI Episode Thumbnail"&gt;&lt;img src="http://img.youtube.com/vi/OvlfCW3Ec1g/0.jpg" class="img-fluid" alt="Same Deep Questions Podcast Debunking AI Episode Thumbnail" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Later in the podcast, Cal takes a question about distributed webs of trust. I agree with Cal's point of using existing open standards like RSS for content consumption. It's the reason you often hear the phrase, &amp;quot;or wherever you get your podcasts&amp;quot;. Assuming you have a program that can read an RSS feed, you can follow all types of content. On the topic of discovery, Cal makes the suggestion of using distributed webs of trust. Using domain names and linking as ways of discovering content. While blogrolls were not directly called out, it's one of the benefits a curated set of links provides.&lt;/p&gt;
]]&gt;</description>
      <link>https://www.lqdev.me/responses/deep-questions-debunking-genai-rss-blogroll</link>
      <guid>https://www.lqdev.me/responses/deep-questions-debunking-genai-rss-blogroll</guid>
      <pubDate>2024-06-24 20:40 -05:00</pubDate>
      <category>ai</category>
      <category>deepquestions</category>
      <category>rss</category>
      <category>calnewport</category>
      <category>podcast</category>
      <category>blogroll</category>
      <category>opml</category>
      <category>social</category>
      <category>socialmedia</category>
      <category>distributedweb</category>
    </item>
    <item>
      <title>New RSS links</title>
      <description>&lt;![CDATA[&lt;p&gt;Based on the post, &lt;a href="https://www.lqdev.me/responses/own-your-rss-links"&gt;own your RSS links&lt;/a&gt;, I decided to set up redirects for all my RSS feeds which was very easy to do using Azure CDN. You can find the updated links in my &lt;a href="https://www.lqdev.me/feed"&gt;feed page&lt;/a&gt;. If you're currently subscribed to any of those feeds, you can keep using the old URLs but I'd recommend updating your feed reader with the latest URLs.&lt;/p&gt;
]]&gt;</description>
      <link>https://www.lqdev.me/notes/new-rss-feed-links</link>
      <guid>https://www.lqdev.me/notes/new-rss-feed-links</guid>
      <pubDate>2024-01-07 19:47 -05:00</pubDate>
      <category>rss</category>
      <category>indieweb</category>
      <category>identity</category>
      <category>social</category>
      <category>posts</category>
    </item>
    <item>
      <title>RSS Only Blog</title>
      <description>&lt;![CDATA[&lt;p&gt;I stumbled upon &lt;a href="https://theunderground.blog/"&gt;theunderground blog&lt;/a&gt; by &lt;a href="https://chrismcleod.dev/"&gt;Chris McLeod&lt;/a&gt; which is an interesting twist on &lt;a href="https://daverupert.com/rss-club/"&gt;RSS Club&lt;/a&gt;. Currently theunderground has a page that serves as the homepage and the RSS feed itself. I wonder whether it's possible to take it even further by using XSL(T) to style the RSS feed as shown in this &lt;a href="https://darekkay.com/blog/rss-styling/"&gt;Style Your RSS Feed&lt;/a&gt; post by &lt;a href="https://darekkay.com/blog/rss-styling/"&gt;Darek Kay&lt;/a&gt;. By styling the RSS feed, it can serve as the homepage as well. Using redirection, when people land on your domain, they would instead be presented with the styled RSS feed.&lt;/p&gt;
]]&gt;</description>
      <link>https://www.lqdev.me/notes/rss-only-blog</link>
      <guid>https://www.lqdev.me/notes/rss-only-blog</guid>
      <pubDate>2023-12-06 21:20 -05:00</pubDate>
      <category>rss</category>
      <category>blogs</category>
      <category>social</category>
    </item>
    <item>
      <title>Webmentions Verification</title>
      <description>&lt;![CDATA[&lt;h2&gt;Description&lt;/h2&gt;
&lt;p&gt;Sample script that shows how to perform Webmention verification per &lt;a href="https://www.w3.org/TR/webmention/#webmention-verification"&gt;Webmentions specification&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Usage&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet fsi webmention-verification.fsx
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Snippet&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;webmention-verification.fsx&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-fsharp"&gt;// https://www.w3.org/TR/webmention/#webmention-verification

#r &amp;quot;nuget:FSharp.Data&amp;quot;
#r &amp;quot;nuget: Microsoft.AspNetCore.WebUtilities, 2.2.0&amp;quot;

open System
open System.Net
open System.Net.Http
open System.Net.Http.Headers
open System.Collections.Generic
open Microsoft.AspNetCore.WebUtilities
open FSharp.Data

type WebmentionVerificationResult = 
    | TaggedMention of {| Replies: bool; Likes: bool; Reposts: bool|}
    | UntaggedMention
    | Error of string

let getFormContent (request:HttpRequestMessage) =
    async {
        let! content = request.Content.ReadAsStringAsync() |&amp;gt; Async.AwaitTask
        let query = QueryHelpers.ParseQuery(content)
        let source = query[&amp;quot;source&amp;quot;] |&amp;gt; Seq.head
        let target = query[&amp;quot;target&amp;quot;] |&amp;gt; Seq.head

        return source,target
    }

let cont =  
    dict [
        (&amp;quot;source&amp;quot;,&amp;quot;https://raw.githubusercontent.com/lqdev/fsadvent-2021-webmentions/main/reply.html&amp;quot;)
        (&amp;quot;target&amp;quot;,&amp;quot;https://webmention.rocks/test/1&amp;quot;)
    ]

let buildSampleRequestMessage (content:IDictionary&amp;lt;string,string&amp;gt;) = 

    let reqMessage = new HttpRequestMessage()
    reqMessage.Content &amp;lt;- new FormUrlEncodedContent(content)

    reqMessage

let req = buildSampleRequestMessage cont

// verification

let source,target = 
    req
    |&amp;gt; getFormContent
    |&amp;gt; Async.RunSynchronously

let getMentionUsingCssSelector (doc:HtmlDocument) (selector:string) (target:string) = 
    doc.CssSelect(selector)
    |&amp;gt; List.map(fun x -&amp;gt; x.AttributeValue(&amp;quot;href&amp;quot;))
    |&amp;gt; List.filter(fun x -&amp;gt; x = target)    

let hasMention (mentions:string list) = 
    mentions |&amp;gt; List.isEmpty |&amp;gt; not

let verifyWebmentions (source:string) (target:string)= 
    async {
        use client = new HttpClient()
        let reqMessage = new HttpRequestMessage(new HttpMethod(&amp;quot;Get&amp;quot;), source)
        reqMessage.Headers.Accept.Clear()
        
        // Only accept text/html content
        reqMessage.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(&amp;quot;text/html&amp;quot;))
        
        // Get document
        let! res = client.SendAsync(reqMessage) |&amp;gt; Async.AwaitTask
        
        // Verify webmention
        let webmentions = 
            match res.IsSuccessStatusCode with 
            | true -&amp;gt;
                // Get document contents
                let body = 
                    async {
                        return! res.Content.ReadAsStringAsync() |&amp;gt; Async.AwaitTask
                    } |&amp;gt; Async.RunSynchronously

                // Parse document
                let doc = HtmlDocument.Parse(body)

                // Get links tagged as replies using microformats
                let replies = 
                    getMentionUsingCssSelector doc &amp;quot;.u-in-reply-to&amp;quot; target

                // Get links tagged as likes using microformats
                let likes = 
                    getMentionUsingCssSelector doc &amp;quot;.u-in-like-of&amp;quot; target

                // Get links tagged as repost using microformats
                let shares = 
                    getMentionUsingCssSelector doc &amp;quot;.u-in-repost-of&amp;quot; target

                // Get untagged mentions
                let mentions = 
                    getMentionUsingCssSelector doc &amp;quot;a&amp;quot; target

                // Collect all tagged mentions
                let knownInteractions = 
                    [replies;likes;shares] 
                    |&amp;gt; List.collect(id)

                // Choose tagged mentions before untagged mentions
                match knownInteractions.IsEmpty,mentions.IsEmpty with 
                | true,true -&amp;gt; Error &amp;quot;Target not mentioned&amp;quot;
                | true,false | false,false -&amp;gt; 
                    TaggedMention 
                        {|
                            Replies = hasMention replies 
                            Likes = hasMention likes
                            Reposts = hasMention shares
                        |}
                | false,true -&amp;gt; UntaggedMention 

            | false -&amp;gt; 
                Error &amp;quot;Unable to get source&amp;quot;
        return webmentions            
    }

verifyWebmentions source target
|&amp;gt; Async.RunSynchronously
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Sample Output&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-text"&gt;Interactions { 
    Likes = false
    Replies = true
    Shares = false }
&lt;/code&gt;&lt;/pre&gt;
]]&gt;</description>
      <link>https://www.lqdev.me/resources/snippets/webmentions-verification</link>
      <guid>https://www.lqdev.me/resources/snippets/webmentions-verification</guid>
      <pubDate>09/25/2022 15:13 -05:00</pubDate>
      <category>f#</category>
      <category>indieweb</category>
      <category>webmentions</category>
      <category>internet</category>
      <category>web</category>
      <category>social</category>
      <category>interactive</category>
      <category>script</category>
    </item>
    <item>
      <title>Webmentions Request Verification</title>
      <description>&lt;![CDATA[&lt;h2&gt;Description&lt;/h2&gt;
&lt;p&gt;Sample script that shows how to perform Webmention request verification per &lt;a href="https://www.w3.org/TR/webmention/#request-verification"&gt;Webmentions specification&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Usage&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet fsi request-verification.fsx
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Snippet&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;request-verification.fsx&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-fsharp"&gt;// https://www.w3.org/TR/webmention/#request-verification

// 1. Send response with 202 Accepted to acknowledge successful request
// 2. DONE: Check that the protocol is http or https
// 3. DONE: Source URL is different than Target URL
// 4. DONE Check that Target URL is a valid resource

#r &amp;quot;nuget: Microsoft.AspNetCore.WebUtilities, 2.2.0&amp;quot;

open System
open System.Net
open System.Net.Http
open System.Collections.Generic
open Microsoft.AspNetCore.WebUtilities

type RequestVerificationResult =
    | Ok of HttpRequestMessage
    | Error of string

// Parse Form URL Encoded string
let getFormContent (request:HttpRequestMessage) =
    async {
        let! content = request.Content.ReadAsStringAsync() |&amp;gt; Async.AwaitTask
        let query = QueryHelpers.ParseQuery(content)
        let source = query[&amp;quot;source&amp;quot;] |&amp;gt; Seq.head
        let target = query[&amp;quot;target&amp;quot;] |&amp;gt; Seq.head

        return source,target
    }

// Check protocol is HTTP or HTTPS
let checkProtocol (request: RequestVerificationResult) =
    match request with 
    | Ok m -&amp;gt; 
        let source,target = 
            async {
                return! getFormContent(m)
            } |&amp;gt; Async.RunSynchronously

        let isProtocolValid = 
            match source.StartsWith(&amp;quot;http&amp;quot;),target.StartsWith(&amp;quot;http&amp;quot;) with
            | true,true -&amp;gt; Ok m
            | true,false -&amp;gt; Error &amp;quot;Target invalid protocol&amp;quot;
            | false,true -&amp;gt;  Error &amp;quot;Source invalid protocol&amp;quot;
            | false,false -&amp;gt; Error &amp;quot;Source and Target invalid protocol&amp;quot;

        isProtocolValid
    | Error s -&amp;gt; Error $&amp;quot;{s}&amp;quot;

// Check the URLs are not the same
let checkUrlsSame (request:RequestVerificationResult) = 
    match request with 
    | Ok m -&amp;gt; 
        let source,target = 
            async {
                return! getFormContent(m)
            } |&amp;gt; Async.RunSynchronously
        let check = 
            match source.Equals(target) with 
            | true -&amp;gt; Error &amp;quot;Urls are the same&amp;quot;
            | false -&amp;gt;  Ok m
        check
    | Error s -&amp;gt; Error s

// Helper functions
let uriIsMine (url:string) = 
    let uri = new Uri(url)
    uri.Host.Equals(&amp;quot;lqdev.me&amp;quot;) || uri.Host.Equals(&amp;quot;www.luisquintanilla.me&amp;quot;) || uri.Host.Equals(&amp;quot;luisquintanilla.me&amp;quot;)

let isValid (url:string) (msg:HttpResponseMessage) = 
    let isMine = uriIsMine url
    isMine &amp;amp; msg.IsSuccessStatusCode

// Check URL is a valid resource
// Valid means, the URL is one of my domains and returns a non-400 or 500 HTML status code
let checkUrlValidResource (request:RequestVerificationResult) = 
    match request with 
    | Ok m -&amp;gt; 
        let res = 
            async {
                let! source,target = getFormContent(m)
                use client = new HttpClient()
                let reqMessage = new HttpRequestMessage(HttpMethod.Head, target)
                let! resp = client.SendAsync(reqMessage) |&amp;gt; Async.AwaitTask
                return isValid target resp
            } |&amp;gt; Async.RunSynchronously
        match res with 
        | true -&amp;gt; Ok m
        | false -&amp;gt; Error &amp;quot;Target is not a valid resource&amp;quot; 
    | Error s -&amp;gt; Error s

// Combine validation steps into single function
let validate = 
    checkProtocol &amp;gt;&amp;gt; checkUrlsSame &amp;gt;&amp;gt; checkUrlValidResource

// Test application
let buildSampleRequestMessages (content:IDictionary&amp;lt;string,string&amp;gt;) = 

    let reqMessage = new HttpRequestMessage()
    reqMessage.Content &amp;lt;- new FormUrlEncodedContent(content)

    let liftedReqMessage = Ok reqMessage
    liftedReqMessage

let sampleContent = [ 
    dict [
        (&amp;quot;source&amp;quot;,&amp;quot;http://lqdev.me&amp;quot;)
        (&amp;quot;target&amp;quot;,&amp;quot;http://lqdev.me&amp;quot;)
    ]
    dict [
        (&amp;quot;source&amp;quot;,&amp;quot;http://://lqdev.me&amp;quot;)
        (&amp;quot;target&amp;quot;,&amp;quot;protocol://lqdev.me&amp;quot;)
    ]    
    dict [
        (&amp;quot;source&amp;quot;,&amp;quot;http://lqdev.me&amp;quot;)
        (&amp;quot;target&amp;quot;,&amp;quot;http://github.com/lqdev&amp;quot;)
    ]
    dict [
        (&amp;quot;source&amp;quot;,&amp;quot;http://github.com/lqdev&amp;quot;)
        (&amp;quot;target&amp;quot;,&amp;quot;http://lqdev.me&amp;quot;)
    ]        
]

sampleContent
|&amp;gt; List.map(buildSampleRequestMessages)
|&amp;gt; List.map(validate)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Sample Output&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-text"&gt;[  
  Error &amp;quot;Urls are the same&amp;quot;; 
  Error &amp;quot;Target invalid protocol&amp;quot;;
  Error &amp;quot;Target is not a valid resource&amp;quot;;
  Ok
    Method: GET, RequestUri: '&amp;lt;null&amp;gt;', Version: 1.1, Content: System.Net.Http.FormUrlEncodedContent, Headers:
    {
        Content-Type: application/x-www-form-urlencoded
        Content-Length: 67
    }
    {
        Content = System.Net.Http.FormUrlEncodedContent;
        Headers = seq [];
        Method = GET;
        Options = seq [];
        Properties = seq [];
        RequestUri = null;
        Version = 1.1;
        VersionPolicy = RequestVersionOrLower;
    }
]
&lt;/code&gt;&lt;/pre&gt;
]]&gt;</description>
      <link>https://www.lqdev.me/resources/snippets/webmentions-request-verification</link>
      <guid>https://www.lqdev.me/resources/snippets/webmentions-request-verification</guid>
      <pubDate>09/23/2022 15:41 -05:00</pubDate>
      <category>f#</category>
      <category>indieweb</category>
      <category>webmentions</category>
      <category>internet</category>
      <category>web</category>
      <category>social</category>
      <category>interactive</category>
      <category>script</category>
    </item>
  </channel>
</rss>