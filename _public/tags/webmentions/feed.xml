<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>Luis Quintanilla - webmentions</title>
    <link>https://www.lqdev.me/tags/webmentions</link>
    <description>All content tagged with 'webmentions' by Luis Quintanilla</description>
    <lastBuildDate>2024-01-16 20:21 -05:00</lastBuildDate>
    <language>en</language>
    <item>
      <title>OpenMentions</title>
      <description>&lt;![CDATA[[reshare] &lt;blockquote class="blockquote"&gt;
&lt;p&gt;OpenMentions is a project designed to use Webmentions and ActivityPub for topical content discovery. The site is organised along the lines of a hierarchy of topics going from broad to fine. This we call OpenTopic â€“ the idea being that many sites could host the full collection of topics so that the loss of any one site is not the loss of all topics.&lt;br /&gt;
&lt;br&gt;
The intention is that this site should own nothing and that topic hierarchies are organic and discoverable.&lt;/p&gt;
&lt;/blockquote&gt;
]]&gt;</description>
      <link>https://www.lqdev.me/responses/openmentions</link>
      <guid>https://www.lqdev.me/responses/openmentions</guid>
      <pubDate>2024-01-16 20:21 -05:00</pubDate>
      <category>webmentions</category>
      <category>indieweb</category>
      <category>activitypub</category>
      <category>online</category>
    </item>
    <item>
      <title>Now accepting webmentions</title>
      <description>&lt;![CDATA[&lt;p&gt;It took me a while to get all the pieces working but I'm excited that my website now accepts &lt;a href="https://www.w3.org/TR/webmention/"&gt;webmentions&lt;/a&gt;!&lt;/p&gt;
&lt;p&gt;A few months ago I implemented &lt;a href="https://www.lqdev.me/notes/webmentions-partially-implemented/"&gt;sending webmentions&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Accepting them was a bit tricky because there were a few design decisions I was optimizing for.&lt;/p&gt;
&lt;p&gt;In the meantime, you can check out &lt;a href="https://github.com/lqdev/WebmentionFs"&gt;WebmentionFs&lt;/a&gt;, an F# library I built for validating and receiving webmentions along with the &lt;a href="https://github.com/lqdev/WebmentionService"&gt;WebmentionService&lt;/a&gt; Azure Functions backend that I'm using to process webmentions for my website.&lt;/p&gt;
&lt;p&gt;Also, feel free to send me a webmention. Here's my endpoint for now &lt;a href="https://lqdevwebmentions.azurewebsites.net/api/inbox"&gt;https://lqdevwebmentions.azurewebsites.net/api/inbox&lt;/a&gt;. Check out this &lt;a href="https://www.lqdev.me/posts/sending-webmentions-fsharp-fsadvent/"&gt;blog post&lt;/a&gt; where I show how you can send webmentions using F#. You can use any HTTP Client of your choosing to send an HTTP POST request to that endpoint with the body containing a link to one of my articles (target) and the link to your post (source).&lt;/p&gt;
&lt;p&gt;Stay tuned for a more detailed post coming on December 21st!&lt;/p&gt;
]]&gt;</description>
      <link>https://www.lqdev.me/notes/now-accepting-webmentions</link>
      <guid>https://www.lqdev.me/notes/now-accepting-webmentions</guid>
      <pubDate>2022-12-18 22:41 -05:00</pubDate>
      <category>indieweb</category>
      <category>webmentions</category>
      <category>community</category>
      <category>fsharp</category>
      <category>azurefunctions</category>
      <category>azure</category>
    </item>
    <item>
      <title>ALMOST ready to receive Webmentions</title>
      <description>&lt;![CDATA[&lt;p&gt;Finally got a working prototype. A few days ago I added the &lt;a href="https://www.lqdev.me/resources/snippets/webmentions-request-verification"&gt;request&lt;/a&gt; and &lt;a href="https://www.lqdev.me/resources/snippets/webmentions-verification"&gt;webmention&lt;/a&gt; verification components.&lt;/p&gt;
&lt;p&gt;I just finished creating the web API and Azure Table Storage components. Now I just need to run some additional tests and deploy it ðŸ™‚&lt;/p&gt;
&lt;p&gt;&lt;img src="https://media.tenor.com/cWNpE2earJkAAAAd/chris-pratt-rubbing-hands.gif" class="img-fluid" alt="Chriss Pratt Rubbing Hands GIF" /&gt;&lt;/p&gt;
]]&gt;</description>
      <link>https://www.lqdev.me/notes/almost-ready-to-receive-webmentions</link>
      <guid>https://www.lqdev.me/notes/almost-ready-to-receive-webmentions</guid>
      <pubDate>2022-10-06 22:29 -05:00</pubDate>
      <category>webmentions</category>
      <category>indieweb</category>
      <category>comments</category>
    </item>
    <item>
      <title>Webmentions Verification</title>
      <description>&lt;![CDATA[&lt;h2&gt;Description&lt;/h2&gt;
&lt;p&gt;Sample script that shows how to perform Webmention verification per &lt;a href="https://www.w3.org/TR/webmention/#webmention-verification"&gt;Webmentions specification&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Usage&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet fsi webmention-verification.fsx
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Snippet&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;webmention-verification.fsx&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-fsharp"&gt;// https://www.w3.org/TR/webmention/#webmention-verification

#r &amp;quot;nuget:FSharp.Data&amp;quot;
#r &amp;quot;nuget: Microsoft.AspNetCore.WebUtilities, 2.2.0&amp;quot;

open System
open System.Net
open System.Net.Http
open System.Net.Http.Headers
open System.Collections.Generic
open Microsoft.AspNetCore.WebUtilities
open FSharp.Data

type WebmentionVerificationResult = 
    | TaggedMention of {| Replies: bool; Likes: bool; Reposts: bool|}
    | UntaggedMention
    | Error of string

let getFormContent (request:HttpRequestMessage) =
    async {
        let! content = request.Content.ReadAsStringAsync() |&amp;gt; Async.AwaitTask
        let query = QueryHelpers.ParseQuery(content)
        let source = query[&amp;quot;source&amp;quot;] |&amp;gt; Seq.head
        let target = query[&amp;quot;target&amp;quot;] |&amp;gt; Seq.head

        return source,target
    }

let cont =  
    dict [
        (&amp;quot;source&amp;quot;,&amp;quot;https://raw.githubusercontent.com/lqdev/fsadvent-2021-webmentions/main/reply.html&amp;quot;)
        (&amp;quot;target&amp;quot;,&amp;quot;https://webmention.rocks/test/1&amp;quot;)
    ]

let buildSampleRequestMessage (content:IDictionary&amp;lt;string,string&amp;gt;) = 

    let reqMessage = new HttpRequestMessage()
    reqMessage.Content &amp;lt;- new FormUrlEncodedContent(content)

    reqMessage

let req = buildSampleRequestMessage cont

// verification

let source,target = 
    req
    |&amp;gt; getFormContent
    |&amp;gt; Async.RunSynchronously

let getMentionUsingCssSelector (doc:HtmlDocument) (selector:string) (target:string) = 
    doc.CssSelect(selector)
    |&amp;gt; List.map(fun x -&amp;gt; x.AttributeValue(&amp;quot;href&amp;quot;))
    |&amp;gt; List.filter(fun x -&amp;gt; x = target)    

let hasMention (mentions:string list) = 
    mentions |&amp;gt; List.isEmpty |&amp;gt; not

let verifyWebmentions (source:string) (target:string)= 
    async {
        use client = new HttpClient()
        let reqMessage = new HttpRequestMessage(new HttpMethod(&amp;quot;Get&amp;quot;), source)
        reqMessage.Headers.Accept.Clear()
        
        // Only accept text/html content
        reqMessage.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(&amp;quot;text/html&amp;quot;))
        
        // Get document
        let! res = client.SendAsync(reqMessage) |&amp;gt; Async.AwaitTask
        
        // Verify webmention
        let webmentions = 
            match res.IsSuccessStatusCode with 
            | true -&amp;gt;
                // Get document contents
                let body = 
                    async {
                        return! res.Content.ReadAsStringAsync() |&amp;gt; Async.AwaitTask
                    } |&amp;gt; Async.RunSynchronously

                // Parse document
                let doc = HtmlDocument.Parse(body)

                // Get links tagged as replies using microformats
                let replies = 
                    getMentionUsingCssSelector doc &amp;quot;.u-in-reply-to&amp;quot; target

                // Get links tagged as likes using microformats
                let likes = 
                    getMentionUsingCssSelector doc &amp;quot;.u-in-like-of&amp;quot; target

                // Get links tagged as repost using microformats
                let shares = 
                    getMentionUsingCssSelector doc &amp;quot;.u-in-repost-of&amp;quot; target

                // Get untagged mentions
                let mentions = 
                    getMentionUsingCssSelector doc &amp;quot;a&amp;quot; target

                // Collect all tagged mentions
                let knownInteractions = 
                    [replies;likes;shares] 
                    |&amp;gt; List.collect(id)

                // Choose tagged mentions before untagged mentions
                match knownInteractions.IsEmpty,mentions.IsEmpty with 
                | true,true -&amp;gt; Error &amp;quot;Target not mentioned&amp;quot;
                | true,false | false,false -&amp;gt; 
                    TaggedMention 
                        {|
                            Replies = hasMention replies 
                            Likes = hasMention likes
                            Reposts = hasMention shares
                        |}
                | false,true -&amp;gt; UntaggedMention 

            | false -&amp;gt; 
                Error &amp;quot;Unable to get source&amp;quot;
        return webmentions            
    }

verifyWebmentions source target
|&amp;gt; Async.RunSynchronously
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Sample Output&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-text"&gt;Interactions { 
    Likes = false
    Replies = true
    Shares = false }
&lt;/code&gt;&lt;/pre&gt;
]]&gt;</description>
      <link>https://www.lqdev.me/resources/snippets/webmentions-verification</link>
      <guid>https://www.lqdev.me/resources/snippets/webmentions-verification</guid>
      <pubDate>09/25/2022 15:13 -05:00</pubDate>
      <category>f#</category>
      <category>indieweb</category>
      <category>webmentions</category>
      <category>internet</category>
      <category>web</category>
      <category>social</category>
      <category>interactive</category>
      <category>script</category>
    </item>
    <item>
      <title>Webmentions Request Verification</title>
      <description>&lt;![CDATA[&lt;h2&gt;Description&lt;/h2&gt;
&lt;p&gt;Sample script that shows how to perform Webmention request verification per &lt;a href="https://www.w3.org/TR/webmention/#request-verification"&gt;Webmentions specification&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Usage&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet fsi request-verification.fsx
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Snippet&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;request-verification.fsx&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-fsharp"&gt;// https://www.w3.org/TR/webmention/#request-verification

// 1. Send response with 202 Accepted to acknowledge successful request
// 2. DONE: Check that the protocol is http or https
// 3. DONE: Source URL is different than Target URL
// 4. DONE Check that Target URL is a valid resource

#r &amp;quot;nuget: Microsoft.AspNetCore.WebUtilities, 2.2.0&amp;quot;

open System
open System.Net
open System.Net.Http
open System.Collections.Generic
open Microsoft.AspNetCore.WebUtilities

type RequestVerificationResult =
    | Ok of HttpRequestMessage
    | Error of string

// Parse Form URL Encoded string
let getFormContent (request:HttpRequestMessage) =
    async {
        let! content = request.Content.ReadAsStringAsync() |&amp;gt; Async.AwaitTask
        let query = QueryHelpers.ParseQuery(content)
        let source = query[&amp;quot;source&amp;quot;] |&amp;gt; Seq.head
        let target = query[&amp;quot;target&amp;quot;] |&amp;gt; Seq.head

        return source,target
    }

// Check protocol is HTTP or HTTPS
let checkProtocol (request: RequestVerificationResult) =
    match request with 
    | Ok m -&amp;gt; 
        let source,target = 
            async {
                return! getFormContent(m)
            } |&amp;gt; Async.RunSynchronously

        let isProtocolValid = 
            match source.StartsWith(&amp;quot;http&amp;quot;),target.StartsWith(&amp;quot;http&amp;quot;) with
            | true,true -&amp;gt; Ok m
            | true,false -&amp;gt; Error &amp;quot;Target invalid protocol&amp;quot;
            | false,true -&amp;gt;  Error &amp;quot;Source invalid protocol&amp;quot;
            | false,false -&amp;gt; Error &amp;quot;Source and Target invalid protocol&amp;quot;

        isProtocolValid
    | Error s -&amp;gt; Error $&amp;quot;{s}&amp;quot;

// Check the URLs are not the same
let checkUrlsSame (request:RequestVerificationResult) = 
    match request with 
    | Ok m -&amp;gt; 
        let source,target = 
            async {
                return! getFormContent(m)
            } |&amp;gt; Async.RunSynchronously
        let check = 
            match source.Equals(target) with 
            | true -&amp;gt; Error &amp;quot;Urls are the same&amp;quot;
            | false -&amp;gt;  Ok m
        check
    | Error s -&amp;gt; Error s

// Helper functions
let uriIsMine (url:string) = 
    let uri = new Uri(url)
    uri.Host.Equals(&amp;quot;lqdev.me&amp;quot;) || uri.Host.Equals(&amp;quot;www.luisquintanilla.me&amp;quot;) || uri.Host.Equals(&amp;quot;luisquintanilla.me&amp;quot;)

let isValid (url:string) (msg:HttpResponseMessage) = 
    let isMine = uriIsMine url
    isMine &amp;amp; msg.IsSuccessStatusCode

// Check URL is a valid resource
// Valid means, the URL is one of my domains and returns a non-400 or 500 HTML status code
let checkUrlValidResource (request:RequestVerificationResult) = 
    match request with 
    | Ok m -&amp;gt; 
        let res = 
            async {
                let! source,target = getFormContent(m)
                use client = new HttpClient()
                let reqMessage = new HttpRequestMessage(HttpMethod.Head, target)
                let! resp = client.SendAsync(reqMessage) |&amp;gt; Async.AwaitTask
                return isValid target resp
            } |&amp;gt; Async.RunSynchronously
        match res with 
        | true -&amp;gt; Ok m
        | false -&amp;gt; Error &amp;quot;Target is not a valid resource&amp;quot; 
    | Error s -&amp;gt; Error s

// Combine validation steps into single function
let validate = 
    checkProtocol &amp;gt;&amp;gt; checkUrlsSame &amp;gt;&amp;gt; checkUrlValidResource

// Test application
let buildSampleRequestMessages (content:IDictionary&amp;lt;string,string&amp;gt;) = 

    let reqMessage = new HttpRequestMessage()
    reqMessage.Content &amp;lt;- new FormUrlEncodedContent(content)

    let liftedReqMessage = Ok reqMessage
    liftedReqMessage

let sampleContent = [ 
    dict [
        (&amp;quot;source&amp;quot;,&amp;quot;http://lqdev.me&amp;quot;)
        (&amp;quot;target&amp;quot;,&amp;quot;http://lqdev.me&amp;quot;)
    ]
    dict [
        (&amp;quot;source&amp;quot;,&amp;quot;http://://lqdev.me&amp;quot;)
        (&amp;quot;target&amp;quot;,&amp;quot;protocol://lqdev.me&amp;quot;)
    ]    
    dict [
        (&amp;quot;source&amp;quot;,&amp;quot;http://lqdev.me&amp;quot;)
        (&amp;quot;target&amp;quot;,&amp;quot;http://github.com/lqdev&amp;quot;)
    ]
    dict [
        (&amp;quot;source&amp;quot;,&amp;quot;http://github.com/lqdev&amp;quot;)
        (&amp;quot;target&amp;quot;,&amp;quot;http://lqdev.me&amp;quot;)
    ]        
]

sampleContent
|&amp;gt; List.map(buildSampleRequestMessages)
|&amp;gt; List.map(validate)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Sample Output&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-text"&gt;[  
  Error &amp;quot;Urls are the same&amp;quot;; 
  Error &amp;quot;Target invalid protocol&amp;quot;;
  Error &amp;quot;Target is not a valid resource&amp;quot;;
  Ok
    Method: GET, RequestUri: '&amp;lt;null&amp;gt;', Version: 1.1, Content: System.Net.Http.FormUrlEncodedContent, Headers:
    {
        Content-Type: application/x-www-form-urlencoded
        Content-Length: 67
    }
    {
        Content = System.Net.Http.FormUrlEncodedContent;
        Headers = seq [];
        Method = GET;
        Options = seq [];
        Properties = seq [];
        RequestUri = null;
        Version = 1.1;
        VersionPolicy = RequestVersionOrLower;
    }
]
&lt;/code&gt;&lt;/pre&gt;
]]&gt;</description>
      <link>https://www.lqdev.me/resources/snippets/webmentions-request-verification</link>
      <guid>https://www.lqdev.me/resources/snippets/webmentions-request-verification</guid>
      <pubDate>09/23/2022 15:41 -05:00</pubDate>
      <category>f#</category>
      <category>indieweb</category>
      <category>webmentions</category>
      <category>internet</category>
      <category>web</category>
      <category>social</category>
      <category>interactive</category>
      <category>script</category>
    </item>
    <item>
      <title>Webmentions (partially) implemented</title>
      <description>&lt;![CDATA[&lt;p&gt;Success! I just partially implemented &lt;a href="https://www.w3.org/TR/webmention/"&gt;Webmentions&lt;/a&gt; for my website. Although I haven't figured out a good way to receive Webmentions yet, I'm able to send them. Fortunately most of the work was done, as detailed in the post &lt;a href="https://www.lqdev.me/posts/sending-webmentions-fsharp-fsadvent/"&gt;Sending Webmentions with F#&lt;/a&gt;. The rest was mainly a matter of adapting it to my static site generator.&lt;/p&gt;
&lt;p&gt;Below is an example of a &lt;a href="https://www.lqdev.me/responses/webmention-test-1/"&gt;post on my website&lt;/a&gt; being displayed in the &lt;a href="https://webmention.rocks/test/1"&gt;Webmention test suite website&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Source&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/11130940/190879250-4554750f-b435-4627-bad9-ecc3d96f9ed0.png" class="img-fluid" alt="Webmention on lqdev.me" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Target&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/11130940/190879274-f6566225-2173-4213-a3d0-eeb9fdc67df9.png" class="img-fluid" alt="Webmention displayed in webmention test suite" /&gt;&lt;/p&gt;
&lt;p&gt;What does this mean? It means I can comment on any website I want, regardless of whether they allow comments or not. As if that weren't enough, I have full ownership of my content as my website is the single source of truth. As a bonus, if the website I comment on supports receiving Webmentions, my post will be displayed on their website / articles as a comment. The next step is to handle deleted comments, but so far I'm happy with the progress.&lt;/p&gt;
]]&gt;</description>
      <link>https://www.lqdev.me/notes/webmentions-partially-implemented</link>
      <guid>https://www.lqdev.me/notes/webmentions-partially-implemented</guid>
      <pubDate>09/17/2022 19:59 -05:00</pubDate>
      <category>indieweb</category>
      <category>webmentions</category>
      <category>fsharp</category>
      <category>website</category>
    </item>
    <item>
      <title>Super simple captcha</title>
      <description>&lt;![CDATA[
## Introduction

I've been thinking about implementing webmentions on this site. According to the spec, "Webmention is a simple way to notify any URL when you mention it on your site. From the receiver's perspective, it's a way to request notifications when other sites mention it". I won't get into the technical details of webmentions in this post, but the simplest way to implement webmentions is to have a text input box on your site for each of your articles, kind of like a comment box. When someone wants to mention your post on their site, they can use the text input box on your site to add the URL from their site where they mention your post. When the user submits the webmention, there's some endpoint that listens for webmention submissions and processes them accordingly. If you're interested in learning more about webmentions, you can check out the following resources:

- [Webmentions spec](https://www.w3.org/TR/webmention/)
- [Webmention Rocks](https://webmention.rocks/)
- [Sending Your First Webmention - IndieWebCamp DÃ¼sseldorf 2019](https://yewtu.be/watch?v=ZOlkS6xP2Zk)

While it's great that you can mention and comment on other people's content from your site, like comments, writing a script to submit spam is relatively simple. Therefore, I want to create some sort of [CAPTCHA](https://en.wikipedia.org/wiki/CAPTCHA) challenge as an initial form of validation to prevent spam. At the same time, I don't want to have any external dependencies. In this post, I'll show how I went about implementing a captcha-like solution with zero dependencies to prevent spam submissions. 

## Simple captcha

The solution I came up with asks the users to add the day of the month (1-31) to a random number between 1-100. While not entirely foolproof, it's "complex" enough that it's not the same thing every time. 

Below is what the implementation looks like. 

![Captcha implementation asking for date](https://user-images.githubusercontent.com/11130940/138604591-dfe4c301-78fe-4338-a751-799b420a1791.png)

The HTML markup for the webpage looks like the following:

```html
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Super Simple Captcha&lt;/title&gt;
    &lt;script src="main.js" type="text/javascript"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body onload="setQuery()"&gt;
    &lt;div&gt;
        &lt;span id="query"&gt;&lt;/span&gt;
        &lt;input type="text" id="answerInput"&gt;
        &lt;button onclick="displayResult()"&gt;Submit&lt;/button&gt;
    &lt;/div&gt;
    &lt;h3 id="result"&gt;&lt;/h3&gt;
&lt;/body&gt;
&lt;/html&gt;
```

When the `body` element of the page loads, it invokes the `setQuery` function, which displays the challenge the user is supposed to solve in the `query` span element. 

The user then submits their answer via the `answerInput` text input box. 

The answer is then checked by invoking the `displayResult` function. The `displayResult` function checks the user's answer against the expected answer. If the answer is correct, the text "OK" is displayed on the page's `result` H3 element. Otherwise, the text "Try again" displays on the webpage.

All of the code that handles this logic is in the `main.js` file.

```javascript
let date = new Date()
let day = date.getDate() // Day of the month
let randomNumber = Math.floor(Math.random() * 100) + 1
let answer = day + randomNumber // Expected answer

let setQuery = () =&gt; {
    let element = document.getElementById('query');
    element.innerText = `Enter the sum of ${day} + ${randomNumber}`;    
}

let checkAnswer = () =&gt; {
    let userAnswer = parseInt(document.getElementById("answerInput").value);
    return answer === userAnswer
}

let displayResult = () =&gt; {
    let result = checkAnswer() ? "OK" : "Try again" // Ternary function to check if answer is correct
    document.getElementById("result").innerText = result;
}
```

That's all there is to it!

## Conclusion

In this post, I showed how to implement a dependency-free solution to present a challenge to users submitting comments / webmentions to your site. Although the solution isn't foolproof, it's just complex enough any spammers would have to work a little harder. Happy coding!  ]]&gt;</description>
      <link>https://www.lqdev.me/posts/super-simple-captcha</link>
      <guid>https://www.lqdev.me/posts/super-simple-captcha</guid>
      <pubDate>10/24/2021 13:00 -05:00</pubDate>
      <category>web development</category>
      <category>html</category>
      <category>javascript</category>
      <category>webmentions</category>
    </item>
  </channel>
</rss>