<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>Luis Quintanilla - os</title>
    <link>https://www.lqdev.me/tags/os</link>
    <description>All content tagged with 'os' by Luis Quintanilla</description>
    <lastBuildDate>2024-07-14 14:49 -05:00</lastBuildDate>
    <language>en</language>
    <item>
      <title>Upgrade NixOS versions</title>
      <description>&lt;![CDATA[&lt;h2&gt;Overview&lt;/h2&gt;
&lt;p&gt;This guide provides general guidance on upgrading between NixOS versions&lt;/p&gt;
&lt;h2&gt;Check which version you're currently running&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;cat /etc/lsb_release
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Get list of channels&lt;/h2&gt;
&lt;p&gt;This provides the URL used to download packages for nixos release&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;nix-channel --list | grep nixos
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Add / Replace Software Channel&lt;/h2&gt;
&lt;p&gt;To get on the latest version, you need to update the &lt;code&gt;nixos&lt;/code&gt; channel to the latest version.&lt;/p&gt;
&lt;p&gt;You can find a list of versions in this &lt;a href="https://channels.nixos.org/"&gt;repository&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;For example, if you wanted to upgrade to the latest 24.05 version, you'd use the following command:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;nix-channel --add https://channels.nixos.org/nixos-24.05 nixos
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The general format is: &lt;code&gt;nix-channel --add &amp;lt;CHANNEL_URL&amp;gt; nixos&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;Rebuild your system&lt;/h2&gt;
&lt;p&gt;Once you've configured the channel for the latest version, switch to it just like you would when upgading sofware packages.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;nixos-rebuild switch --upgrade
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the operation completes, you'll want to check which version is running as mentioned in previous instructions.&lt;/p&gt;
&lt;h2&gt;Additional Resources&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://nlewo.github.io/nixos-manual-sphinx/installation/upgrading.xml.html"&gt;Upgrading Nix OS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
]]&gt;</description>
      <link>https://www.lqdev.me/resources/wiki/nix-upgrade-versions</link>
      <guid>https://www.lqdev.me/resources/wiki/nix-upgrade-versions</guid>
      <pubDate>2024-07-14 14:49 -05:00</pubDate>
      <category>linux</category>
      <category>sysadmin</category>
      <category>nixos</category>
      <category>nix</category>
      <category>os</category>
    </item>
    <item>
      <title>Garbage Collections NixOS</title>
      <description>&lt;![CDATA[&lt;h2&gt;Overview&lt;/h2&gt;
&lt;p&gt;One of the nice things about NixOS is, whenever you update the system, old configurations remain in place. That way if something were to go wrong, you can always revert back. However, there are tradeoffs. Each old configuration takes up space on your hard drive. If you're updating your system every week or every few weeks, this adds up. The following is a general guide on how to clean these up.&lt;/p&gt;
&lt;h2&gt;Delete old generations&lt;/h2&gt;
&lt;p&gt;This command deletes every generation, except the most current one.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;nix-env --delete-generations old
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you'd like to keep a few of the most recent ones. Say, from the last 14 days, you can pass an argument.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;nix-env --delete-generations 14d
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Run the garbage collector&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;nix-store --gc
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Use the nix-collect-garbage utility&lt;/h2&gt;
&lt;p&gt;The following utility will delete older generations across all profiles on your system.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;nix-collect-garbage -d
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Resources&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://nixos.org/manual/nix/stable/package-management/garbage-collection.html"&gt;NixOS Garbage Collection&lt;/a&gt;&lt;/p&gt;
]]&gt;</description>
      <link>https://www.lqdev.me/resources/wiki/nixos-garbage-collection</link>
      <guid>https://www.lqdev.me/resources/wiki/nixos-garbage-collection</guid>
      <pubDate>03/10/2024 14:01 -05:00</pubDate>
      <category>nixos</category>
      <category>system</category>
      <category>os</category>
      <category>linux</category>
    </item>
    <item>
      <title>MemGPT - Towards LLMs as Operating Systems</title>
      <description>&lt;![CDATA[[bookmark] &lt;blockquote class="blockquote"&gt;
&lt;p&gt;Teach LLMs to manage their own memory for unbounded context!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;Large language models (LLMs) have revolutionized AI, but are constrained by limited context windows, hindering their utility in tasks like extended conversations and document analysis. To enable using context beyond limited context windows, we propose virtual context management, a technique drawing inspiration from hierarchical memory systems in traditional operating systems that provide the appearance of large memory resources through data movement between fast and slow memory. Using this technique, we introduce MemGPT (Memory-GPT), a system that intelligently manages different memory tiers in order to effectively provide extended context within the LLM's limited context window, and utilizes interrupts to manage control flow between itself and the user. We evaluate our OS-inspired design in two domains where the limited context windows of modern LLMs severely handicaps their performance: document analysis, where MemGPT is able to analyze large documents that far exceed the underlying LLM's context window, and multi-session chat, where MemGPT can create conversational agents that remember, reflect, and evolve dynamically through long-term interactions with their users. We release MemGPT code and data for our experiments at https://memgpt.ai.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;In MemGPT, a fixed-context LLM processor is augmented with a tiered memory system and a set of functions that allow it to manage its own memory. Main context is the (fixed-length) LLM input. MemGPT parses the LLM text ouputs at each processing cycle, and either yields control or executes a function call, which can be used to move data between main and external context. When the LLM generates a function call, it can request immediate return of execution to chain together functions. In the case of a yield, the LLM will not be run again until the next external event trigger (e.g. a user message or scheduled interrupt).&lt;/p&gt;
&lt;/blockquote&gt;
]]&gt;</description>
      <link>https://www.lqdev.me/bookmarks/memgpt-llm-operating-system</link>
      <guid>https://www.lqdev.me/bookmarks/memgpt-llm-operating-system</guid>
      <pubDate>2023-12-11 19:58 -05:00</pubDate>
      <category>ai</category>
      <category>os</category>
      <category>llm</category>
    </item>
    <item>
      <title>SerenityOS</title>
      <description>&lt;![CDATA[[bookmark] &lt;blockquote class="blockquote"&gt;
&lt;p&gt;A graphical Unix-like operating system for desktop computers!&lt;/p&gt;
&lt;p&gt;SerenityOS is a love letter to '90s user interfaces with a custom Unix-like core. It flatters with sincerity by stealing beautiful ideas from various other systems.&lt;/p&gt;
&lt;p&gt;Roughly speaking, the goal is a marriage between the aesthetic of late-1990s productivity software and the power-user accessibility of late-2000s *nix.&lt;/p&gt;
&lt;p&gt;This is a system by us, for us, based on the things we like.&lt;/p&gt;
&lt;/blockquote&gt;
]]&gt;</description>
      <link>https://www.lqdev.me/bookmarks/serenity-os</link>
      <guid>https://www.lqdev.me/bookmarks/serenity-os</guid>
      <pubDate>2023-08-24 18:57 -05:00</pubDate>
      <category>os</category>
      <category>linux</category>
      <category>90s</category>
      <category>serenityos</category>
      <category>retro</category>
    </item>
    <item>
      <title>NixOS Configuration</title>
      <description>&lt;![CDATA[&lt;h2&gt;Description&lt;/h2&gt;
&lt;p&gt;This is my NixOS Configuration file&lt;/p&gt;
&lt;h2&gt;Usage&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Update configuration file&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Run the following command to apply changes&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;sudo nixos-rebuild switch
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Snippet&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-nix"&gt;# Edit this configuration file to define what should be installed on
# your system.  Help is available in the configuration.nix(5) man page
# and in the NixOS manual (accessible by running ‘nixos-help’).

{ config, pkgs, ... }:

{
  imports =
    [ # Include the results of the hardware scan.
      ./hardware-configuration.nix
    ];

  # Bootloader.
  boot.loader.systemd-boot.enable = true;
  boot.loader.efi.canTouchEfiVariables = true;

  networking.hostName = &amp;quot;nixos&amp;quot;; # Define your hostname.
  # networking.wireless.enable = true;  # Enables wireless support via wpa_supplicant.

  # Configure network proxy if necessary
  # networking.proxy.default = &amp;quot;http://user:password@proxy:port/&amp;quot;;
  # networking.proxy.noProxy = &amp;quot;127.0.0.1,localhost,internal.domain&amp;quot;;

  # Enable networking
  networking.networkmanager.enable = true;

  # Set your time zone.
  time.timeZone = &amp;quot;America/New_York&amp;quot;;

  # Select internationalisation properties.
  i18n.defaultLocale = &amp;quot;en_US.UTF-8&amp;quot;;

  i18n.extraLocaleSettings = {
    LC_ADDRESS = &amp;quot;en_US.UTF-8&amp;quot;;
    LC_IDENTIFICATION = &amp;quot;en_US.UTF-8&amp;quot;;
    LC_MEASUREMENT = &amp;quot;en_US.UTF-8&amp;quot;;
    LC_MONETARY = &amp;quot;en_US.UTF-8&amp;quot;;
    LC_NAME = &amp;quot;en_US.UTF-8&amp;quot;;
    LC_NUMERIC = &amp;quot;en_US.UTF-8&amp;quot;;
    LC_PAPER = &amp;quot;en_US.UTF-8&amp;quot;;
    LC_TELEPHONE = &amp;quot;en_US.UTF-8&amp;quot;;
    LC_TIME = &amp;quot;en_US.UTF-8&amp;quot;;
  };

  # Enable the X11 windowing system.
  # services.xserver.enable = true;
  services.xserver = {
    enable = true;

    desktopManager = {
      xterm.enable = false;
    };

    displayManager = {
      defaultSession = &amp;quot;none+i3&amp;quot;;
    };

    windowManager.i3 = {
       enable = true;
       extraPackages = with pkgs; [
         dmenu
	 i3status
         j4-dmenu-desktop
	 i3lock	
       ];
    };
  };

  # Enable the XFCE Desktop Environment.
  # services.xserver.displayManager.lightdm.enable = true;
  # services.xserver.desktopManager.xfce.enable = true;

  # Configure keymap in X11
  services.xserver = {
    layout = &amp;quot;us&amp;quot;;
    xkbVariant = &amp;quot;&amp;quot;;
  };

  # Enable CUPS to print documents.
  services.printing.enable = true;

  # Enable sound with pipewire.
  sound.enable = true;
  hardware.pulseaudio.enable = false;
  security.rtkit.enable = true;
  services.pipewire = {
    enable = true;
    alsa.enable = true;
    alsa.support32Bit = true;
    pulse.enable = true;
    # If you want to use JACK applications, uncomment this
    #jack.enable = true;

    # use the example session manager (no others are packaged yet so this is enabled by default,
    # no need to redefine it in your config for now)
    #media-session.enable = true;
  };

  # Enable touchpad support (enabled default in most desktopManager).
  # services.xserver.libinput.enable = true;

  # Enable gvfs
  services.gvfs.enable = true;

  # Define a user account. Don't forget to set a password with ‘passwd’.
  users.users.lqdev = {
    isNormalUser = true;
    description = &amp;quot;lqdev&amp;quot;;
    extraGroups = [ &amp;quot;networkmanager&amp;quot; &amp;quot;wheel&amp;quot; &amp;quot;docker&amp;quot;];
    packages = with pkgs; [
      firefox
      thunderbird
      vscode
      element-desktop
    ];
  };

  #Enable docker
  virtualisation.docker.enable = true;

  # Allow unfree packages
  nixpkgs.config.allowUnfree = true;

  # List packages installed in system profile. To search, run:
  # $ nix search wget
  environment.systemPackages = with pkgs; [
  #  vim # Do not forget to add an editor to edit configuration.nix! The Nano editor is also installed by default.

  # Utilities
    wget
    emacs
    alacritty
    mc
    du-dust
    htop
    feh
    duf
    shutter
    gparted
    keepassxc
    bitwarden
    git
    yt-dlp
    streamlink
    ffmpeg
    gnome.seahorse
    xfce.thunar-volman
    xfce.xfconf

  # Media
  
    mpv
    vlc
    
  # Dotnet
    (with dotnetCorePackages; combinePackages [
      dotnet-sdk
      dotnet-sdk_7
    ])
  # Development
  
    docker
    cargo
    rustc

  # Office
  
    libreoffice
  ];

  # Some programs need SUID wrappers, can be configured further or are
  # started in user sessions.
  # programs.mtr.enable = true;
  # programs.gnupg.agent = {
  #   enable = true;
  #   enableSSHSupport = true;
  # };

  # Bash Configuration
  programs.bash = {
    shellAliases = {
      emacs=&amp;quot;emacs -nw&amp;quot;;
    };
  };

  # Thunar
  programs.thunar.enable = true;

  # List services that you want to enable:

  # Enable the OpenSSH daemon.
  # services.openssh.enable = true;

  # Open ports in the firewall.
  # networking.firewall.allowedTCPPorts = [ ... ];
  # networking.firewall.allowedUDPPorts = [ ... ];
  # Or disable the firewall altogether.
  # networking.firewall.enable = false;

  # This value determines the NixOS release from which the default
  # settings for stateful data, like file locations and database versions
  # on your system were taken. It‘s perfectly fine and recommended to leave
  # this value at the release version of the first install of this system.
  # Before changing this value read the documentation for this option
  # (e.g. man configuration.nix or on https://nixos.org/nixos/options.html).
  system.stateVersion = &amp;quot;23.05&amp;quot;; # Did you read the comment?

}
&lt;/code&gt;&lt;/pre&gt;
]]&gt;</description>
      <link>https://www.lqdev.me/resources/snippets/nixos-configuration</link>
      <guid>https://www.lqdev.me/resources/snippets/nixos-configuration</guid>
      <pubDate>08/22/2023 18:45 -05:00</pubDate>
      <category>nix</category>
      <category>linux</category>
      <category>configuration</category>
      <category>nixos</category>
      <category>os</category>
    </item>
    <item>
      <title>First Steps with NixOS</title>
      <description>&lt;![CDATA[
## Introduction

For the longest time, when using Linux distributions, I chose those that were Debian-based. I still do for servers. However, on the dekstop I switched to [Manjaro](https://manjaro.org/), which is Arch-based, about two years ago. Two years is a long time without distro-hopping, so I was long overdue. I've been following the [NixOS](https://nixos.org/) project for some time but since I was happy with my setup, I didn't consider making the switch. However, a month ago, I decided to [dip my toes](/notes/maybe-switching-nixos). I installed NixOS on a flash drive and started tinkering with it. In this post, I'll provide some of my initial impressions and things I find appealing about the OS.

## Declarative configuration

One of the first things I did when I booted into my new NixOS installation was get familiar with the [configuration file](https://nixos.wiki/wiki/Overview_of_the_NixOS_Linux_distribution#Declarative_Configuration). The configuration file is authored using the [Nix programming language](https://nix.dev/tutorials/first-steps/nix-language) and it's the place where you configure your entire system, including services, packages, and desktop environments. The best way I can describe it is a Dockerfile for your desktop. If interested, you can find my [config file](/resources/snippets/nixos-configuration/) on the scripts section of this website. 


There's a few advantages to this approach:

1. **Configurations are stored in a single place** - The advantage to this is, I don't have to figure out where the configuration files for each of the components of my system are. I can manage everything in one place. A perfect example where the configuration file goes beyond what I expected was being able to include my bash configuration. Typically, I'd have that configuration in my `bashrc` file. With NixOS, I can just include that in the configuration file as follows:


    ```nix
    programs.bash = {
        shellAliases = {
            emacs="emacs -nw";
        };
    };
    ```

1. **Enables composition** - Because the configuration file is effectively a script, I can modularize the difference pieces. For example, if I wanted to split out my service and package configurations into separate files, I can do so and reference those individual files from my configuration file, separating concerns while still keeping my system configuration simple. 
1. **Version control** - Because the configuration file is just like any other plain text file, it means I can check it into the version control system or cloud service of my choice and manage it that way. In doing so, not only can I roll back using the built-in NixOS mechanisms, but I have another layer of security in case I need to recover that file. 

Now, because I can define everything about my system in the configuration file, this means I can seamlessly rebuild my entire system using this single file in a reproducible manner.

## Reproducible builds

I got to experience first-hand how the configuration file can simplify out-of-box-experiences and system configurations. Initially, I did not install NixOS on my main hard drive. All of my configuration and learning took place on a flash drive. Once I got my configuration to a place I was satisfied, it was time to take the plunge and reimage my PC. In the past, when I've done something similar, I've had to document everything I did when configuring my system. That's where posts like [Setting up a new Ubuntu PC](/posts/setting-up-new-ubuntu-pc/) come from. With NixOS, all I needed to do was replace my configuration file with the one I configured on the flash drive. Then, when I ran `nixos-rebuild switch`, my system was configured exactly like the one on the flash drive. 

## Risk-free software evaluations

This is something I haven't tried yet, but I could easily see it coming in handy. Sometimes I might need a piece of software to do one thing or maybe I want to see whether it'll solve a problem I'm facing. In order to try it out and use it, I need to install it globally. This can cause changes to my system permanently that I don't want. With NixOS, you can create [ad-hoc shell environments](https://nix.dev/tutorials/first-steps/ad-hoc-shell-environments#ad-hoc-shell-environments). These environments make temporary changes to your system, so you can evaluate a piece of software or use it that one time. Then, when you exit the environment, the software is no longer installed in your system.

## Large package selection

A [large package selection](https://search.nixos.org/packages) to choose from is something I got used to with Manjaro. Being an Arch-based distribution, I had access to the [Arch User Repository (AUR)](https://aur.archlinux.org/). Moving to NixOS, it's nice to know that in this area, NixOS offers great support. Additionally, NixOS has built-in support for [Flatpak](https://nixos.wiki/wiki/Flatpak)

## Still exploring

There's still a few things I don't really get. For example, when installing the .NET SDK, I wanted to have side-by-side installs of the latest STS (7.0) and LTS (6.0). However, including the package names in my configuration file didn't work as expected. Instead I had to use the following convention.

```nix
(with dotnetCorePackages; combinePackages [
    dotnet-sdk
    dotnet-sdk_7
])
```

As I learn more, this will probably make more sense but for now it's a mystery. 

## Conclusion

Overall, I'm happy with NixOS and I can see myself using it for the long-term. Hopefully longer than two years. I'm not a gamer so I can't say how well it does in that front. For web browsing and software development though, I really like what NixOS has to offer. If some of the things I mentioned above sound interesting, I'd encourage you to install it on a flash drive and start tinkering with it. ]]&gt;</description>
      <link>https://www.lqdev.me/posts/first-steps-nixos</link>
      <guid>https://www.lqdev.me/posts/first-steps-nixos</guid>
      <pubDate>2023-08-22 18:03 -05:00</pubDate>
      <category>nixos</category>
      <category>linux</category>
      <category>os</category>
      <category>nix</category>
      <category>sysadmin</category>
      <category>floss</category>
    </item>
  </channel>
</rss>