<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>Luis Quintanilla - interactive</title>
    <link>https://www.lqdev.me/tags/interactive</link>
    <description>All content tagged with 'interactive' by Luis Quintanilla</description>
    <lastBuildDate>09/25/2022 15:13 -05:00</lastBuildDate>
    <language>en</language>
    <item>
      <title>Webmentions Verification</title>
      <description>&lt;![CDATA[&lt;h2&gt;Description&lt;/h2&gt;
&lt;p&gt;Sample script that shows how to perform Webmention verification per &lt;a href="https://www.w3.org/TR/webmention/#webmention-verification"&gt;Webmentions specification&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Usage&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet fsi webmention-verification.fsx
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Snippet&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;webmention-verification.fsx&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-fsharp"&gt;// https://www.w3.org/TR/webmention/#webmention-verification

#r &amp;quot;nuget:FSharp.Data&amp;quot;
#r &amp;quot;nuget: Microsoft.AspNetCore.WebUtilities, 2.2.0&amp;quot;

open System
open System.Net
open System.Net.Http
open System.Net.Http.Headers
open System.Collections.Generic
open Microsoft.AspNetCore.WebUtilities
open FSharp.Data

type WebmentionVerificationResult = 
    | TaggedMention of {| Replies: bool; Likes: bool; Reposts: bool|}
    | UntaggedMention
    | Error of string

let getFormContent (request:HttpRequestMessage) =
    async {
        let! content = request.Content.ReadAsStringAsync() |&amp;gt; Async.AwaitTask
        let query = QueryHelpers.ParseQuery(content)
        let source = query[&amp;quot;source&amp;quot;] |&amp;gt; Seq.head
        let target = query[&amp;quot;target&amp;quot;] |&amp;gt; Seq.head

        return source,target
    }

let cont =  
    dict [
        (&amp;quot;source&amp;quot;,&amp;quot;https://raw.githubusercontent.com/lqdev/fsadvent-2021-webmentions/main/reply.html&amp;quot;)
        (&amp;quot;target&amp;quot;,&amp;quot;https://webmention.rocks/test/1&amp;quot;)
    ]

let buildSampleRequestMessage (content:IDictionary&amp;lt;string,string&amp;gt;) = 

    let reqMessage = new HttpRequestMessage()
    reqMessage.Content &amp;lt;- new FormUrlEncodedContent(content)

    reqMessage

let req = buildSampleRequestMessage cont

// verification

let source,target = 
    req
    |&amp;gt; getFormContent
    |&amp;gt; Async.RunSynchronously

let getMentionUsingCssSelector (doc:HtmlDocument) (selector:string) (target:string) = 
    doc.CssSelect(selector)
    |&amp;gt; List.map(fun x -&amp;gt; x.AttributeValue(&amp;quot;href&amp;quot;))
    |&amp;gt; List.filter(fun x -&amp;gt; x = target)    

let hasMention (mentions:string list) = 
    mentions |&amp;gt; List.isEmpty |&amp;gt; not

let verifyWebmentions (source:string) (target:string)= 
    async {
        use client = new HttpClient()
        let reqMessage = new HttpRequestMessage(new HttpMethod(&amp;quot;Get&amp;quot;), source)
        reqMessage.Headers.Accept.Clear()
        
        // Only accept text/html content
        reqMessage.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(&amp;quot;text/html&amp;quot;))
        
        // Get document
        let! res = client.SendAsync(reqMessage) |&amp;gt; Async.AwaitTask
        
        // Verify webmention
        let webmentions = 
            match res.IsSuccessStatusCode with 
            | true -&amp;gt;
                // Get document contents
                let body = 
                    async {
                        return! res.Content.ReadAsStringAsync() |&amp;gt; Async.AwaitTask
                    } |&amp;gt; Async.RunSynchronously

                // Parse document
                let doc = HtmlDocument.Parse(body)

                // Get links tagged as replies using microformats
                let replies = 
                    getMentionUsingCssSelector doc &amp;quot;.u-in-reply-to&amp;quot; target

                // Get links tagged as likes using microformats
                let likes = 
                    getMentionUsingCssSelector doc &amp;quot;.u-in-like-of&amp;quot; target

                // Get links tagged as repost using microformats
                let shares = 
                    getMentionUsingCssSelector doc &amp;quot;.u-in-repost-of&amp;quot; target

                // Get untagged mentions
                let mentions = 
                    getMentionUsingCssSelector doc &amp;quot;a&amp;quot; target

                // Collect all tagged mentions
                let knownInteractions = 
                    [replies;likes;shares] 
                    |&amp;gt; List.collect(id)

                // Choose tagged mentions before untagged mentions
                match knownInteractions.IsEmpty,mentions.IsEmpty with 
                | true,true -&amp;gt; Error &amp;quot;Target not mentioned&amp;quot;
                | true,false | false,false -&amp;gt; 
                    TaggedMention 
                        {|
                            Replies = hasMention replies 
                            Likes = hasMention likes
                            Reposts = hasMention shares
                        |}
                | false,true -&amp;gt; UntaggedMention 

            | false -&amp;gt; 
                Error &amp;quot;Unable to get source&amp;quot;
        return webmentions            
    }

verifyWebmentions source target
|&amp;gt; Async.RunSynchronously
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Sample Output&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-text"&gt;Interactions { 
    Likes = false
    Replies = true
    Shares = false }
&lt;/code&gt;&lt;/pre&gt;
]]&gt;</description>
      <link>https://www.lqdev.me/resources/snippets/webmentions-verification</link>
      <guid>https://www.lqdev.me/resources/snippets/webmentions-verification</guid>
      <pubDate>09/25/2022 15:13 -05:00</pubDate>
      <category>f#</category>
      <category>indieweb</category>
      <category>webmentions</category>
      <category>internet</category>
      <category>web</category>
      <category>social</category>
      <category>interactive</category>
      <category>script</category>
    </item>
    <item>
      <title>Webmentions Request Verification</title>
      <description>&lt;![CDATA[&lt;h2&gt;Description&lt;/h2&gt;
&lt;p&gt;Sample script that shows how to perform Webmention request verification per &lt;a href="https://www.w3.org/TR/webmention/#request-verification"&gt;Webmentions specification&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Usage&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;dotnet fsi request-verification.fsx
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Snippet&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;request-verification.fsx&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-fsharp"&gt;// https://www.w3.org/TR/webmention/#request-verification

// 1. Send response with 202 Accepted to acknowledge successful request
// 2. DONE: Check that the protocol is http or https
// 3. DONE: Source URL is different than Target URL
// 4. DONE Check that Target URL is a valid resource

#r &amp;quot;nuget: Microsoft.AspNetCore.WebUtilities, 2.2.0&amp;quot;

open System
open System.Net
open System.Net.Http
open System.Collections.Generic
open Microsoft.AspNetCore.WebUtilities

type RequestVerificationResult =
    | Ok of HttpRequestMessage
    | Error of string

// Parse Form URL Encoded string
let getFormContent (request:HttpRequestMessage) =
    async {
        let! content = request.Content.ReadAsStringAsync() |&amp;gt; Async.AwaitTask
        let query = QueryHelpers.ParseQuery(content)
        let source = query[&amp;quot;source&amp;quot;] |&amp;gt; Seq.head
        let target = query[&amp;quot;target&amp;quot;] |&amp;gt; Seq.head

        return source,target
    }

// Check protocol is HTTP or HTTPS
let checkProtocol (request: RequestVerificationResult) =
    match request with 
    | Ok m -&amp;gt; 
        let source,target = 
            async {
                return! getFormContent(m)
            } |&amp;gt; Async.RunSynchronously

        let isProtocolValid = 
            match source.StartsWith(&amp;quot;http&amp;quot;),target.StartsWith(&amp;quot;http&amp;quot;) with
            | true,true -&amp;gt; Ok m
            | true,false -&amp;gt; Error &amp;quot;Target invalid protocol&amp;quot;
            | false,true -&amp;gt;  Error &amp;quot;Source invalid protocol&amp;quot;
            | false,false -&amp;gt; Error &amp;quot;Source and Target invalid protocol&amp;quot;

        isProtocolValid
    | Error s -&amp;gt; Error $&amp;quot;{s}&amp;quot;

// Check the URLs are not the same
let checkUrlsSame (request:RequestVerificationResult) = 
    match request with 
    | Ok m -&amp;gt; 
        let source,target = 
            async {
                return! getFormContent(m)
            } |&amp;gt; Async.RunSynchronously
        let check = 
            match source.Equals(target) with 
            | true -&amp;gt; Error &amp;quot;Urls are the same&amp;quot;
            | false -&amp;gt;  Ok m
        check
    | Error s -&amp;gt; Error s

// Helper functions
let uriIsMine (url:string) = 
    let uri = new Uri(url)
    uri.Host.Equals(&amp;quot;lqdev.me&amp;quot;) || uri.Host.Equals(&amp;quot;www.luisquintanilla.me&amp;quot;) || uri.Host.Equals(&amp;quot;luisquintanilla.me&amp;quot;)

let isValid (url:string) (msg:HttpResponseMessage) = 
    let isMine = uriIsMine url
    isMine &amp;amp; msg.IsSuccessStatusCode

// Check URL is a valid resource
// Valid means, the URL is one of my domains and returns a non-400 or 500 HTML status code
let checkUrlValidResource (request:RequestVerificationResult) = 
    match request with 
    | Ok m -&amp;gt; 
        let res = 
            async {
                let! source,target = getFormContent(m)
                use client = new HttpClient()
                let reqMessage = new HttpRequestMessage(HttpMethod.Head, target)
                let! resp = client.SendAsync(reqMessage) |&amp;gt; Async.AwaitTask
                return isValid target resp
            } |&amp;gt; Async.RunSynchronously
        match res with 
        | true -&amp;gt; Ok m
        | false -&amp;gt; Error &amp;quot;Target is not a valid resource&amp;quot; 
    | Error s -&amp;gt; Error s

// Combine validation steps into single function
let validate = 
    checkProtocol &amp;gt;&amp;gt; checkUrlsSame &amp;gt;&amp;gt; checkUrlValidResource

// Test application
let buildSampleRequestMessages (content:IDictionary&amp;lt;string,string&amp;gt;) = 

    let reqMessage = new HttpRequestMessage()
    reqMessage.Content &amp;lt;- new FormUrlEncodedContent(content)

    let liftedReqMessage = Ok reqMessage
    liftedReqMessage

let sampleContent = [ 
    dict [
        (&amp;quot;source&amp;quot;,&amp;quot;http://lqdev.me&amp;quot;)
        (&amp;quot;target&amp;quot;,&amp;quot;http://lqdev.me&amp;quot;)
    ]
    dict [
        (&amp;quot;source&amp;quot;,&amp;quot;http://://lqdev.me&amp;quot;)
        (&amp;quot;target&amp;quot;,&amp;quot;protocol://lqdev.me&amp;quot;)
    ]    
    dict [
        (&amp;quot;source&amp;quot;,&amp;quot;http://lqdev.me&amp;quot;)
        (&amp;quot;target&amp;quot;,&amp;quot;http://github.com/lqdev&amp;quot;)
    ]
    dict [
        (&amp;quot;source&amp;quot;,&amp;quot;http://github.com/lqdev&amp;quot;)
        (&amp;quot;target&amp;quot;,&amp;quot;http://lqdev.me&amp;quot;)
    ]        
]

sampleContent
|&amp;gt; List.map(buildSampleRequestMessages)
|&amp;gt; List.map(validate)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Sample Output&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-text"&gt;[  
  Error &amp;quot;Urls are the same&amp;quot;; 
  Error &amp;quot;Target invalid protocol&amp;quot;;
  Error &amp;quot;Target is not a valid resource&amp;quot;;
  Ok
    Method: GET, RequestUri: '&amp;lt;null&amp;gt;', Version: 1.1, Content: System.Net.Http.FormUrlEncodedContent, Headers:
    {
        Content-Type: application/x-www-form-urlencoded
        Content-Length: 67
    }
    {
        Content = System.Net.Http.FormUrlEncodedContent;
        Headers = seq [];
        Method = GET;
        Options = seq [];
        Properties = seq [];
        RequestUri = null;
        Version = 1.1;
        VersionPolicy = RequestVersionOrLower;
    }
]
&lt;/code&gt;&lt;/pre&gt;
]]&gt;</description>
      <link>https://www.lqdev.me/resources/snippets/webmentions-request-verification</link>
      <guid>https://www.lqdev.me/resources/snippets/webmentions-request-verification</guid>
      <pubDate>09/23/2022 15:41 -05:00</pubDate>
      <category>f#</category>
      <category>indieweb</category>
      <category>webmentions</category>
      <category>internet</category>
      <category>web</category>
      <category>social</category>
      <category>interactive</category>
      <category>script</category>
    </item>
  </channel>
</rss>