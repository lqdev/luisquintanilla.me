<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>Luis Quintanilla - orgmode</title>
    <link>https://www.lqdev.me/tags/orgmode</link>
    <description>All content tagged with 'orgmode' by Luis Quintanilla</description>
    <lastBuildDate>2024-07-29 21:45 -05:00</lastBuildDate>
    <language>en</language>
    <item>
      <title>User-provided target file names in Org Capture</title>
      <description>&lt;![CDATA[&lt;p&gt;I finally got my website note org-capture template working for new files.&lt;/p&gt;
&lt;p&gt;Originally, I only had it working on existing files using this snippet.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-elisp"&gt;(&amp;quot;wne&amp;quot;
 &amp;quot;Creates a note in an existing file&amp;quot;
 plain
 (file buffer-file-name)
 (file ,(file-name-concat website-template-dir &amp;quot;note.txt&amp;quot;)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This template uses the file name of the current buffer to select the insertion target.&lt;/p&gt;
&lt;p&gt;Getting it to work with a new file specified by the user, requires a small tweak.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-elisp"&gt;(&amp;quot;wnn&amp;quot;
 &amp;quot;Creates a note in a new file&amp;quot;
 plain
 (file (lambda () (file-name-concat website-note-dir (format &amp;quot;%s.md&amp;quot; (read-string &amp;quot;Enter file name: &amp;quot;)))))
 (file ,(file-name-concat website-template-dir &amp;quot;note.txt&amp;quot;)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;At first, I thought I had to use the &lt;code&gt;function&lt;/code&gt; target type since I wanted to use a function to capture the file name. That didn't work.&lt;/p&gt;
&lt;p&gt;I then realized, I could still keep the &lt;code&gt;file&lt;/code&gt; target type. However, to fill in the file name, I could use a function which takes in user input.&lt;/p&gt;
&lt;p&gt;Now that I got this working, I've also done the same for my reponse template.&lt;/p&gt;
]]&gt;</description>
      <link>https://www.lqdev.me/notes/org-capture-functions-file-target</link>
      <guid>https://www.lqdev.me/notes/org-capture-functions-file-target</guid>
      <pubDate>2024-07-29 21:45 -05:00</pubDate>
      <category>emacs</category>
      <category>orgmode</category>
      <category>capture</category>
      <category>org</category>
      <category>website</category>
      <category>templates</category>
      <category>gnu</category>
    </item>
    <item>
      <title>Nyxt Emacs Hacks</title>
      <description>&lt;![CDATA[[bookmark] &lt;p&gt;Saving this guide for future reference as I set up my elfeed / Nyxt capture workflows for the website.&lt;/p&gt;
&lt;p&gt;Additional articles that might be helpful.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://ag91.github.io/blog/2021/07/09/org-capture-in-nyxt-taking-notes-while-browsing/"&gt;Org capture in Nyxt: Taking Notes While Browsing&lt;/a&gt;&lt;/p&gt;
]]&gt;</description>
      <link>https://www.lqdev.me/bookmarks/nyxt-emacs-hacks</link>
      <guid>https://www.lqdev.me/bookmarks/nyxt-emacs-hacks</guid>
      <pubDate>2024-07-28 16:53 -05:00</pubDate>
      <category>nyxt</category>
      <category>emacs</category>
      <category>orgmode</category>
      <category>capture</category>
      <category>templates</category>
      <category>workflow</category>
      <category>lisp</category>
    </item>
    <item>
      <title>Test response using org capture templates</title>
      <description>&lt;![CDATA[[reshare] &lt;p&gt;Testing org-capture template generated response file&lt;/p&gt;
]]&gt;</description>
      <link>https://www.lqdev.me/responses/test-emacs-capture-response-org</link>
      <guid>https://www.lqdev.me/responses/test-emacs-capture-response-org</guid>
      <pubDate>2024-07-14 13:47 -05:00</pubDate>
      <category>org</category>
      <category>emacs</category>
      <category>blogging</category>
      <category>automation</category>
      <category>orgmode</category>
      <category>templates</category>
      <category>capturetemplates</category>
      <category>website</category>
      <category>personalweb</category>
      <category>capture</category>
    </item>
    <item>
      <title>Clock Tables - Org Mode, Plain Text, and AI</title>
      <description>&lt;![CDATA[&lt;p&gt;Org-mode appreciation post.&lt;/p&gt;
&lt;p&gt;I use plain text and org-mode for most things in my life, especially when it comes to task and life management.&lt;/p&gt;
&lt;p&gt;I won't rehash all the reasons Emacs and org-mode are amazing. There are tons of blog posts and videos out there that would do it more justice than I ever could.&lt;/p&gt;
&lt;p&gt;Over the last few years, Emacs has become my go-to text editor. Throughout all that time, I've continued to find new features that delight.&lt;/p&gt;
&lt;p&gt;The most recent is &lt;a href="https://orgmode.org/manual/The-clock-table.html"&gt;clock table&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I already use org-mode to track my to-dos and perform some sort of time-block planning by setting deadlines and scheduling tasks.&lt;/p&gt;
&lt;p&gt;Recently though, I've been wanting a way to see all of the things I've worked on over the past [ INSERT TIME PERIOD ]. More importantly, I'd like to have time associated with them to see where my time has gone and evaluate whether I'm spending time on the things I should be.&lt;/p&gt;
&lt;p&gt;I knew you could &lt;a href="https://orgmode.org/manual/Clocking-commands.html"&gt;clock in and clock out&lt;/a&gt; on tasks. However, I didn't know you could easily build a customized report that automatically updates. That's when I came across clock tables.&lt;/p&gt;
&lt;p&gt;Now, I have a way of visualizing all of the things I worked on during a week or month, and as I'm planning for the next week or month, I can adjust and reprioritize the things I'm working on.&lt;/p&gt;
&lt;p&gt;I know there are enterprise offerings like the Viva suite from Microsoft which provides detailed reports on how you spend your time.&lt;/p&gt;
&lt;p&gt;What excites me about org-mode though is that it's plain text. The clock table report that gets generated is a plain text table which makes it portable and easy to access using any text editor of your choice. It works best with Emacs, but that's not a requirement.&lt;/p&gt;
&lt;p&gt;On their own, clock tables are amazing.&lt;/p&gt;
&lt;p&gt;However, given how well language models work on plain text, they could be used as context for your queries. Imagine giving a language model as input an org file which contains:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A clock table&lt;/li&gt;
&lt;li&gt;A list of TODO tasks (with notes, priorities, deadlines, tags, properties, and other annotations)&lt;/li&gt;
&lt;li&gt;A high level list of goals you want to achieve&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Then, you could enter a prompt along the lines of: &amp;quot;Using the following clock-table and list of goals I want to achieve, provide me with recommendations of tasks I should work on for the next week. Ensure that they align with my goals, are top priority, and provide the highest return on my efforts&amp;quot;.&lt;/p&gt;
&lt;p&gt;Additionally, you might also provide your org-agenda view containing appointments and use the results from the first query as context for the following prompt: &amp;quot;Given the agenda view for the next week, schedule the top 3 tasks you recommended&amp;quot;.&lt;/p&gt;
&lt;p&gt;The result would be a list of TODO items containing schedule / active timestamps annotations which now show up on your org-agenda view.&lt;/p&gt;
&lt;p&gt;Today, almost every productivity application out there is working on building these kinds of AI features into their products. The difference is, in many cases, the formats used by those applications aren't plain text. This adds complexity to the data extraction and transformation pipelines required to get the data into the right format for a language model to process. With plain text, there's little to no transformations required.&lt;/p&gt;
&lt;p&gt;What's even better, I can extend org-mode and Emacs using elisp to do the things I just talked about.&lt;/p&gt;
&lt;p&gt;I'm no elisp expert, so I asked Copilot to generate an elisp function that takes an org-mode clock table as input and generates a written text summary of it. Here are the results:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-lisp"&gt;(defun org-clock-summary-to-chatgpt ()
  &amp;quot;Extracts clock table data and requests a summary from ChatGPT.&amp;quot;
  (interactive)
  (let* ((clock-table-data (org-clocktable-get-clocktable))
         (summary-text (org-clocktable-format-summary clock-table-data))
         (api-endpoint &amp;quot;https://api.openai.com/v1/engines/davinci/completions&amp;quot;)
         (api-key &amp;quot;YOUR_API_KEY&amp;quot;)) ; Replace with your actual API key

    ;; Construct the HTTP request and send it to ChatGPT
    (with-current-buffer
        (url-retrieve-synchronously api-endpoint
                                    `((&amp;quot;text&amp;quot; . ,summary-text)
                                      (&amp;quot;api_key&amp;quot; . ,api-key)))
      (goto-char (point-min))
      (search-forward &amp;quot;\n\n&amp;quot;)
      (let ((response-json (json-read)))
        (message &amp;quot;ChatGPT summary: %s&amp;quot; (cdr (assoc 'choices response-json)))))))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;All you elisp experts out there, let me know how it did.&lt;/p&gt;
&lt;p&gt;I know at least the API endpoint is wrong, but generally speaking, it seems to be doing the right thing. Such function could be extended to include org-agenda information, TODO items, and many other things that would use AI to augment the existing functionality of Emacs and org-mode to tailor them to my needs.&lt;/p&gt;
]]&gt;</description>
      <link>https://www.lqdev.me/notes/love-plain-text-org-mode-clocktable</link>
      <guid>https://www.lqdev.me/notes/love-plain-text-org-mode-clocktable</guid>
      <pubDate>2024-07-09 22:07 -05:00</pubDate>
      <category>emacs</category>
      <category>orgmode</category>
      <category>ai</category>
      <category>plaintext</category>
      <category>productivity</category>
      <category>tools</category>
      <category>technology</category>
      <category>gnu</category>
      <category>opensource</category>
      <category>gtd</category>
      <category>calendar</category>
      <category>agenda</category>
      <category>llm</category>
      <category>openai</category>
    </item>
  </channel>
</rss>